--- upstart-1.5.orig/ChangeLog
+++ upstart-1.5/ChangeLog
@@ -1,5 +1,10 @@
 2012-03-22  James Hunt  <james.hunt@ubuntu.com>
 
+	* NEWS: Begin new release.
+	* configure.ac: Bump version to 1.6.
+
+2012-03-22  James Hunt  <james.hunt@ubuntu.com>
+
 	* Changelog: Release entry.
 	* configure.ac: Bump year.
 	* NEWS: Release 1.5.
--- upstart-1.5.orig/conf/rc-sysinit.conf
+++ upstart-1.5/conf/rc-sysinit.conf
@@ -6,7 +6,7 @@
 description	"System V initialisation compatibility"
 author		"Scott James Remnant <scott@netsplit.com>"
 
-start on startup
+start on (filesystem and static-network-up) or failsafe-boot
 stop on runlevel
 
 # Default runlevel, this may be overriden on the kernel command-line
@@ -23,9 +23,11 @@
 env RUNLEVEL=
 env PREVLEVEL=
 
+console output
+env INIT_VERBOSE
+
 task
 
-console owner
 script
     # Check for default runlevel in /etc/inittab
     if [ -r /etc/inittab ]
--- upstart-1.5.orig/conf/rc.conf
+++ upstart-1.5/conf/rc.conf
@@ -6,13 +6,18 @@
 description	"System V runlevel compatibility"
 author		"Scott James Remnant <scott@netsplit.com>"
 
+emits deconfiguring-networking
+emits unmounted-remote-filesystems
+
 start on runlevel [0123456]
 stop on runlevel [!$RUNLEVEL]
 
 export RUNLEVEL
 export PREVLEVEL
 
+console output
+env INIT_VERBOSE
+
 task
 
-console output
 exec /etc/init.d/rc $RUNLEVEL
--- upstart-1.5.orig/dbus/Upstart.conf
+++ upstart-1.5/dbus/Upstart.conf
@@ -9,14 +9,12 @@
     <allow own="com.ubuntu.Upstart" />
   </policy>
 
-  <!-- Allow any user to invoke all of the methods on Upstart, its jobs
-       or their instances, and to get and set properties - since Upstart
-       isolates commands by user. -->
-  <policy context="default">
-    <allow send_destination="com.ubuntu.Upstart"
-	   send_interface="org.freedesktop.DBus.Introspectable" />
+  <!-- Permit the root user to invoke all of the methods on Upstart, its jobs
+       or their instances, and to get and set properties. -->
+  <policy user="root">
     <allow send_destination="com.ubuntu.Upstart"
 	   send_interface="org.freedesktop.DBus.Properties" />
+
     <allow send_destination="com.ubuntu.Upstart"
 	   send_interface="com.ubuntu.Upstart0_6" />
     <allow send_destination="com.ubuntu.Upstart"
@@ -24,4 +22,36 @@
     <allow send_destination="com.ubuntu.Upstart"
 	   send_interface="com.ubuntu.Upstart0_6.Instance" />
   </policy>
+
+  <!-- Allow any user to introspect Upstart's interfaces, to obtain the
+       values of properties (but not set them) and to invoke selected
+       methods on Upstart and its jobs that are used to walk information. -->
+  <policy context="default">
+    <allow send_destination="com.ubuntu.Upstart"
+	   send_interface="org.freedesktop.DBus.Introspectable" />
+
+    <allow send_destination="com.ubuntu.Upstart"
+	   send_interface="org.freedesktop.DBus.Properties"
+	   send_type="method_call" send_member="Get" />
+    <allow send_destination="com.ubuntu.Upstart"
+	   send_interface="org.freedesktop.DBus.Properties"
+	   send_type="method_call" send_member="GetAll" />
+
+    <allow send_destination="com.ubuntu.Upstart"
+	   send_interface="com.ubuntu.Upstart0_6"
+	   send_type="method_call" send_member="GetJobByName" />
+    <allow send_destination="com.ubuntu.Upstart"
+	   send_interface="com.ubuntu.Upstart0_6"
+	   send_type="method_call" send_member="GetAllJobs" />
+
+    <allow send_destination="com.ubuntu.Upstart"
+	   send_interface="com.ubuntu.Upstart0_6.Job"
+	   send_type="method_call" send_member="GetInstance" />
+    <allow send_destination="com.ubuntu.Upstart"
+	   send_interface="com.ubuntu.Upstart0_6.Job"
+	   send_type="method_call" send_member="GetInstanceByName" />
+    <allow send_destination="com.ubuntu.Upstart"
+	   send_interface="com.ubuntu.Upstart0_6.Job"
+	   send_type="method_call" send_member="GetAllInstances" />
+  </policy>
 </busconfig>
--- upstart-1.5.orig/debian/README.Debian
+++ upstart-1.5/debian/README.Debian
@@ -0,0 +1,200 @@
+upstart
+=======
+
+Upstart is a replacement for the traditional sysvinit package, and
+runs as process #1.  Through upstart, we are able to have an
+event-driven process, whilst at the same time retaining compatibility
+for the original sysvinit behaviour.
+
+This file documents how to do a few common operations with the new
+system.
+
+
+Where are initscripts installed?
+--------------------------------
+
+This has not changed, they are installed in /etc/init.d.  See
+/etc/init.d/README.
+
+Important system jobs are no longer shipped as initscripts, but as
+upstart jobs.  These are installed in /etc/init
+
+
+How are initscripts started and stopped?
+----------------------------------------
+
+This has not changed, symlinks are made from the initscript in the
+/etc/init.d directory to the /etc/rc?.d directories.  See
+/etc/init.d/README and /etc/rc?.d/README.
+
+
+What order are initscripts started and stopped in?
+--------------------------------------------------
+
+This has not changed, the symlinks are named SNNname or KNNname, where
+NN is a number from 00 to 99.  The K scripts are run first in
+numerical order, followed by the S scripts in numerical order.
+
+
+How do I find the current/previous runlevel?
+--------------------------------------------
+
+This has not changed, use the "runlevel" command.  See runlevel(8).
+
+
+How do I change the runlevel?
+-----------------------------
+
+This has not changed, use the "telinit" command or just invoke "init"
+directly.  See telinit(8).
+
+
+How do I change the default runlevel?
+-------------------------------------
+
+If you have an /etc/inittab file, edit it.  Locate the following line:
+
+    id:N:initdefault:
+
+Where N is the default runlevel, change this to match.
+
+Most people won't have that file, you can edit /etc/init/rc-sysinit.conf
+and change the following line:
+
+    env DEFAULT_RUNLEVEL=2
+
+
+How do I shutdown the machine?
+------------------------------
+
+This has not changed, use the "shutdown" command provided by the
+upstart package; you may also use the "reboot"/"halt"/"poweroff"
+commands as a short-cut.  See shutdown(8) and reboot(8).
+
+You can also press Control-Alt-Delete on a console to reboot the
+machine.
+
+
+How do I change the behaviour of Control-Alt-Delete?
+----------------------------------------------------
+
+Edit the /etc/init/control-alt-delete.conf file, the line beginning
+"exec" is what upstart will run when this key combination is pressed.
+
+To not do anything, you can simply delete this file.
+
+
+How do I enter single-user mode?
+--------------------------------
+
+This hasn't changed, choose the "(recovery mode)" option from GRUB;
+add "-s", "S" or "single" to the kernel command-line; or from a
+running machine, run "telinit 1" or "shutdown now".
+
+
+How do I reduce the number of gettys?
+-------------------------------------
+
+Also see "How do I change which runlevels gettys are run in?"
+
+In /etc/init there is a file named ttyN.conf for each getty that will be
+started, where N is numbered 1 to 6.  Remove any that you do not
+want.
+
+This will not take immediate effect, however you can run "stop ttyN"
+to stop one that is running.
+
+
+How do I change getty parameters?
+---------------------------------
+
+In /etc/init there is a file named ttyN.conf for each getty that will be
+started, where N is numbered 1 to 6.  Edit these files, the line
+beginning "respawn" is what upstart will run.
+
+This will not take immediate effect, run "stop ttyN" followed by
+"start ttyN" or just kill the running getty to respawn with the new
+parameters.
+
+
+How do I change which runlevels gettys are run in?
+--------------------------------------------------
+
+In /etc/init there is a file named ttyN.conf for each getty that will be
+started, where N is numbered 1 to 6.  Edit these files, there are two
+lines:
+
+   start on runlevel [2345]
+   stop on runlevel [!2345]
+
+Change the set of runlevels to match your taste.
+
+This will not take immediate effect, however you can run "stop ttyN"
+to stop one that is running or "start ttyN" to start one that isn't.
+
+
+How do I increase the number of gettys?
+---------------------------------------
+
+In /etc/init there is a file named ttyN.conf for each getty that will be
+started, where N is numbered 1 to 6.
+
+Copy one of these files to a new name, we suggest you simply name it
+after the tty, e.g. "ttyS0".
+
+Edit that file, change the "respawn" line to match your requirements;
+in particular you'll need to change the tty the getty should be run
+on.
+
+This will not take immediate effect, however you can run "start ttyN"
+to start the getty.
+
+
+How do I add a serial console?
+------------------------------
+
+See "How do I increase the number of gettys?"
+
+
+How can I see boot messages on the console?
+-------------------------------------------
+
+This is nothing to do with upstart, but I'll answer this anyway.
+Remove "quiet" from the kernel command-line.
+
+To make this permanent, edit /boot/grub/menu.lst and edit the line
+that begins "# defoptions=" (yes, it looks like a comment).
+
+This will change both usplash and the LSB init logging.
+
+
+Upstart isn't working, how do I debug it?
+-----------------------------------------
+
+Add "--debug" to the kernel command-line, and be sure to remove "quiet"
+and "splash".  You'll now see debugging messages as upstart works.
+
+
+Can I query upstart for a list of jobs?
+---------------------------------------
+
+Yes, "initctl list" will list the known jobs and their status.
+
+
+How do I manually start or stop a job?
+--------------------------------------
+
+Use "start JOB" or "stop JOB".
+
+
+How do I find the status of a job?
+----------------------------------
+
+Use "status JOB".
+
+
+Can I emit an event by hand?
+----------------------------
+
+Yes, "initctl emit EVENT" will emit the named event and cause any
+jobs waiting for it to be started or stopped as appropriate.
--- upstart-1.5.orig/debian/apparmor-profile-load
+++ upstart-1.5/debian/apparmor-profile-load
@@ -0,0 +1,30 @@
+#!/bin/sh
+# apparmor-profile-load
+#
+# Helper for loading an AppArmor profile in pre-start scripts.
+
+[ -z "$1" ]                  && exit 1 # require a profile name
+
+# do not load in a container
+[ -x /bin/running-in-container ] && /bin/running-in-container && exit 0
+
+[ -d /rofs/etc/apparmor.d ]  && exit 0 # do not load if running liveCD
+
+profile=/etc/apparmor.d/"$1"
+[ -e "$profile" ]            || exit 0 # skip when missing profile
+
+module=/sys/module/apparmor
+[ -d $module ]               || exit 0 # do not load without AppArmor in kernel
+
+[ -x /sbin/apparmor_parser ] || exit 0 # do not load without parser
+
+aafs=/sys/kernel/security/apparmor
+[ -d $aafs ]                 || exit 0 # do not load if unmounted
+[ -w $aafs/.load ]           || exit 1 # fail if cannot load profiles
+
+params=$module/parameters
+[ -r $params/enabled ]       || exit 0 # do not load if missing
+read enabled < $params/enabled || exit 1 # if this fails, something went wrong
+[ "$enabled" = "Y" ]         || exit 0 # do not load if disabled
+
+/sbin/apparmor_parser -r -W "$profile"
--- upstart-1.5.orig/debian/changelog
+++ upstart-1.5/debian/changelog
@@ -0,0 +1,1261 @@
+upstart (1.5-0ubuntu7.3) precise-proposed; urgency=medium
+
+  * init/conf.c: conf_delete_handler(): Clear error if conf_reload_path()
+    fails (LP: #1430403).
+
+ -- James Hunt <james.hunt@ubuntu.com>  Wed, 11 Mar 2015 14:00:42 +0000
+
+upstart (1.5-0ubuntu7.2) precise-proposed; urgency=low
+
+  * Cherry-pick newer test code to fix test failure seen
+    on ARM (LP: #980917).
+
+ -- James Hunt <james.hunt@ubuntu.com>  Thu, 17 Jan 2013 11:39:27 +0000
+
+upstart (1.5-0ubuntu7.1) precise-proposed; urgency=low
+
+  * Cherry-pick SRU update from quantal to allow initramfs-less
+    boot (LP: #980917).
+
+ -- James Hunt <james.hunt@ubuntu.com>  Wed, 21 Nov 2012 14:21:10 +0000
+
+upstart (1.5-0ubuntu7) precise-proposed; urgency=low
+
+  * Correct a build failure from the previous upload.
+
+ -- Steve Langasek <steve.langasek@ubuntu.com>  Thu, 26 Apr 2012 07:48:17 -0700
+
+upstart (1.5-0ubuntu6) precise-proposed; urgency=low
+
+  * debian/upstart.logrotate: don't create empty files after rotation;
+    upstart will automatically create new log files for jobs as needed.
+  * init/main.c: restore the fix for bug #540256; we know the console setup
+    is taken care of by plymouth in Ubuntu, so upstart changing the console
+    settings just makes trouble (such as turning echo back on when it
+    shouldn't be).  LP: #876626.
+
+  [ James Hunt ]
+  * debian/upstart-job: Only attempt to handle disabled jobs if the running
+    version of Upstart supports such a query (LP: #985755, #984474).
+  * debian/manpages/upstart-events.7: Fixed typo and corrected reference to
+    'kill signal' stanza. 
+
+ -- Steve Langasek <steve.langasek@ubuntu.com>  Wed, 25 Apr 2012 13:23:34 -0700
+
+upstart (1.5-0ubuntu5) precise; urgency=low
+
+  * debian/upstart-job: Add in handling for disabled jobs:
+    - Do not restart a job if disabled, unless job was forcibly started.
+    - Do stop a disabled job that was forcibly started.
+    Resolves issue where 'invoke-rc.d restart' erroneously started disabled
+    jobs on package upgrade (LP: #974147)
+
+ -- James Hunt <james.hunt@ubuntu.com>  Tue, 10 Apr 2012 09:19:03 +0100
+
+upstart (1.5-0ubuntu4) precise; urgency=low
+
+  * debian/apparmor-profile-load: don't run in a container. This can
+    hopefully be removed after stacked profiles are supported and
+    used by lxc. (LP: #978297)
+
+ -- Serge Hallyn <serge.hallyn@ubuntu.com>  Tue, 10 Apr 2012 14:55:41 -0500
+
+upstart (1.5-0ubuntu3) precise; urgency=low
+
+  * debian/manpages/upstart-events.7: Correct emitter for
+    "static-network-up" event.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Wed, 28 Mar 2012 11:59:56 +0100
+
+upstart (1.5-0ubuntu2) precise; urgency=low
+
+  * debian/conf/flush-early-job-log.conf: Change initctl command from
+    'flush-early-job-log' to 'notify-disk-writeable' to reflect new name.
+  * init/man/init.8: Remove duplicate telinit(8).
+  * debian/manpages/upstart-events.7:
+    - Added table 'Job Goals and State Transitions'.
+    - Corrected errors and omissions in 'Job Lifecycle' section.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Wed, 28 Mar 2012 11:00:04 +0100
+
+upstart (1.5-0ubuntu1) precise; urgency=low
+
+  * FFe.  LP: #962124.
+  * New upstream 1.5 release.
+    - fix boot failure when /dev/pts is not mounted before upstart starts.
+      LP: #936667.
+    - fix a file descriptor leak on job restarts.  LP: #940290.
+  * debian/conf/failsafe.conf: Added missing "emits" which breaks
+    'initctl check-config'.
+  * debian/manpages/upstart-events.7: Added 'failsafe-boot' and
+    'recovery' events.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Thu, 22 Mar 2012 13:50:31 +0000
+
+upstart (1.4-0ubuntu9) precise; urgency=low
+
+  [ Steve Langasek ]
+  * debian/conf/failsafe.conf: instead of waiting for the 'runlevel' event
+    before considering failsafe done, stop this job as soon as we're
+    starting rc-sysinit; that way, any delays in /etc/rcS.d will not cause
+    confusing messages about networking delays when the network is not the
+    problem. (LP: #950662)
+
+  [ James Hunt ]
+  * init/log.c:log_read_watch(): Set remote_closed for scenarios where error
+     handler never called. (LP: #935585)
+
+  [ Serge Hally ]
+  * debian/conf/power-status-changed.conf: shut down on getting SIGPWR.
+    Unprivileged tasks can't send this signal.  In particular this will
+    allow clean shutdown of containers from the host. 
+    (See http://www.makelinux.net/man/7/P/power-status-changed)
+
+  [ Stéphane Graber ]
+  * Rename Serge's job to shutdown.conf to avoid a name conflict with the
+    event power-status-changed.
+
+ -- Stéphane Graber <stgraber@ubuntu.com>  Fri, 16 Mar 2012 13:48:04 -0400
+
+upstart (1.4-0ubuntu8) precise; urgency=low
+
+  * init/tests/test_job_process.c:
+    - close_all_files(): Correct type of index variable.
+    - test_run():
+      - "with single line command writing lots of data fast and exiting":
+        - add waitid() call to ensure log is not added to unflushed list.
+      - "with log object freed on process exit":
+        - add waitid() call to ensure log is not added to unflushed list.
+  * util/tests/test_initctl.c: test_flush_early_job_log():
+    - "with job ending before log disk writeable": Give Upstart a chance
+      to run the job as sometimes we see the job pid in the output which
+      causes the test to fail.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Fri, 17 Feb 2012 10:58:02 -0500
+
+upstart (1.4-0ubuntu7) precise; urgency=low
+
+  * debian/manpages/upstart-events.7: Added missing events 'container' and
+    'not-container'.
+  * Update 'runlevel' event emission time in upstart-events(7) (LP: #921501).
+  * Merge of important upstream log fixes to avoid spinning when a job
+    which leaks fds (such as 'sshd -D') is stopped (LP: #926468).
+  * Merge of lp:~jamesodhunt/upstart/early-job-log-flush to allow jobs that
+    _end_ very early in the boot to have their output logged.
+  * debian/conf/flush-early-job-log.conf: Upstart job to force flushing of
+    early job log output data when disk becomes writeable.
+  * Re-enable job logging by default.
+
+  [ Steve Langasek ]
+  * init/tests/test_job_process.c: close all fds before running tests that
+    check for unexpected open fds, so that files leaked from the environment
+    don't cause the test suite to fail gratuitously.  LP: #926473.
+  * bump debhelper compat to 9 and adjust debian/rules to use the
+    dpkg-buildflags interfaces, so that upstart can be cross-compiled and
+    also so we pick up any future hardening flags for free.
+
+ -- Steve Langasek <steve.langasek@ubuntu.com>  Thu, 16 Feb 2012 07:52:11 +0000
+
+upstart (1.4-0ubuntu6) precise; urgency=low
+
+  [ Serge Hallyn ]
+  * debian/conf/container-detect.conf: an upstart job to track whether upstart
+    detected itself running in a container.
+  * debian/running-in-container: a script using container.conf to
+    answer whether upstart is running in a container.
+  * debian/conf/console.conf: run getty on /dev/console when running
+    in a lxc container.
+  * debian/control: conflict with lxcguest.
+
+  [ Stéphane Graber ]
+  * debian/conf/container-detect.conf: extend to also detect OpenVZ and vserver
+    as well as write the type in /run/container_type and emit either:
+    - container CONTAINER=type
+      (where type is lxc, lxc-libvirt, openvz or vserver)
+    - not-container
+  * debian/running-in-container: extend to also print the type of container.
+  * Rebase debian/conf/console.conf on debian/conf/tty1.conf.
+  * Update tty[1234].conf to start on regular machines and LXC containers.
+  * Update tty[56].conf to only start on regular machines.
+
+ -- Stéphane Graber <stgraber@ubuntu.com>  Wed, 08 Feb 2012 16:44:59 -0500
+
+upstart (1.4-0ubuntu5) precise; urgency=low
+
+  * Merge of important upstream log fixes to handle scenario attempts
+    are made to exec(3) directly non-existent commands. (LP: #922754)
+
+ -- James Hunt <james.hunt@ubuntu.com>  Fri, 03 Feb 2012 14:16:40 +0000
+
+upstart (1.4-0ubuntu4) precise; urgency=low
+
+  * Disable job logging by default again due to a reported regression with
+    plymouth-upstart-bridge and upstart itself taking 100% CPU.  Use --log
+    at boot time again for testing.
+
+ -- Steve Langasek <steve.langasek@ubuntu.com>  Fri, 27 Jan 2012 11:04:05 -0800
+
+upstart (1.4-0ubuntu3) precise; urgency=low
+
+  [ Stéphane Graber ]
+  * Mark upstart Multi-Arch:foreign
+
+  [ James Hunt ]
+  * Merge of important logger fixes from upstream lp:upstart
+    (LP: #912558).
+  * Reverted temporary fix to disable job logging. 
+
+ -- James Hunt <james.hunt@ubuntu.com>  Thu, 26 Jan 2012 15:13:25 +0000
+
+upstart (1.4-0ubuntu2) precise; urgency=low
+
+  * init/main.c: Temporarily disable default job logging whilst
+    investigating bug 912558 (can be re-enabled with
+    _temporary_ '--log' option).
+
+ -- James Hunt <james.hunt@ubuntu.com>  Fri, 06 Jan 2012 16:11:23 +0000
+
+upstart (1.4-0ubuntu1) precise; urgency=low
+
+  * New upstream 1.4 release.
+  * debian/upstart.dirs: Create /var/log/upstart to hold job logs.
+  * debian/upstart.logrotate: Logrotate script for job logs.
+  * po/en@boldquot.gmo, po/en@quot.gmo: Overwrite with upstream versions to
+    keep bzr happy. This makes the files technically "wrong" (since the
+    Ubuntu Upstart code has additional messages not in upstream), but they get
+    re-genrated on build so it all works out.
+  * debian/manpages/upstart-events.7: Add missing 'static-network-up'
+    event (LP: #889047).
+  *  debian/manpages/upstart-events.7: Add missing
+     'deconfiguring-networking' event (LP: #904175).
+  * Upstream merge for minor test fixes.
+  * Upstream merge for review fixes.
+  * Merge of upstream fix for running tests in environment not
+    supporting full POSIX SIGCHLD semantics.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Thu, 22 Dec 2011 16:51:43 +0000
+
+upstart (1.3-0ubuntu11) oneiric-proposed; urgency=low
+
+  * debian/conf/failsafe.conf: stop on static-network-up, so that a slow
+    runlevel switch doesn't leave a confusing message on screen about
+    starting up without networking.  LP: #881079.
+
+ -- Steve Langasek <steve.langasek@ubuntu.com>  Wed, 26 Oct 2011 12:05:47 -0700
+
+upstart (1.3-0ubuntu10) oneiric; urgency=low
+
+  [ Clint Byrum ]
+  * debian/conf/failsafe.conf: do delay as script, not pre-start, so
+    that the messages/delays are stopped on runlevel immediately. emit
+    as an event, failsafe-boot, to provide finer grained control.
+    (LP: #863864)
+  * conf/rc-sysinit.conf: change from 'started failsafe' to 'failsafe-boot'
+    to accomodate changes to failsafe.conf.
+
+  [ Steve Langasek ]
+  * Document device-not-ready in upstart-events(7).  LP: #805510.
+  * Document desktop-shutdown in upstart-events(7).  LP: #854329.
+  * Mention lightdm in the list of example DMs in upstart-events(7), since
+    it's now the default...
+
+ -- Steve Langasek <steve.langasek@ubuntu.com>  Mon, 03 Oct 2011 18:37:04 -0700
+
+upstart (1.3-0ubuntu9) oneiric; urgency=low
+
+  * Update rcS.conf to only start single user mode but not friendly-recovery.
+    (LP: #575469)
+  * Mark upstart as breaking friendly-recovery << 0.2.13
+
+ -- Stéphane Graber <stgraber@ubuntu.com>  Thu, 15 Sep 2011 16:04:17 -0400
+
+upstart (1.3-0ubuntu8) oneiric; urgency=low
+
+  * debian/conf/failsafe.conf: Add plymouth messages to help users
+    understand why the system boot takes longer when they have
+    static network interfaces defined. (LP: #847782)
+
+ -- Clint Byrum <clint@ubuntu.com>  Wed, 14 Sep 2011 18:53:10 -0700
+
+upstart (1.3-0ubuntu7) oneiric; urgency=low
+
+  * debian/conf/failsafe.conf: raise timeout to 120 seconds to
+    allow for very slow DHCP interfaces to come up on servers.
+    (LP: #839595)
+
+ -- Clint Byrum <clint@ubuntu.com>  Sun, 04 Sep 2011 09:29:27 -0700
+
+upstart (1.3-0ubuntu6) oneiric; urgency=low
+
+  [ Steve Langasek ]
+  * Fix maintainer field to be compliant with policy definition
+
+  [ Clint Byrum ]
+  * conf/rc.conf: document events that are emitted by sysvinit
+    jobs to quiet 'initctl check-config' 
+  * extra/conf/upstart-udev-bridge.conf: narrow definition to
+    only the events actually emitted. (LP: #819928)
+  * debian/conf/failsafe.conf: new job for critical services to
+    start on.
+  * conf/rc-sysinit.conf: start after static-network-up or failsafe
+    so that runlevel 2 is only entered with all static net interfaces
+    up. (LP: #580319)
+
+ -- Clint Byrum <clint@ubuntu.com>  Wed, 10 Aug 2011 08:44:43 -0500
+
+upstart (1.3-0ubuntu5) oneiric; urgency=low
+
+  * Upstream cherry-pick for user session fixes
+    ("bzr merge -r 1318..1324 lp:upstart").
+
+ -- James Hunt <james.hunt@ubuntu.com>  Mon, 25 Jul 2011 17:09:47 +0100
+
+upstart (1.3-0ubuntu4) oneiric; urgency=low
+
+  * init/main.c: main(): Add support for "/run" directory with fallback to
+    old location for initramfs state passing (LP: #810956).
+  * Upstream cherry-pick to get dbus fix ("bzr merge -r 1314.. lp:upstart"). 
+
+ -- James Hunt <james.hunt@ubuntu.com>  Wed, 20 Jul 2011 14:51:04 +0100
+
+upstart (1.3-0ubuntu3) oneiric; urgency=low
+
+  * init/paths.h: Syned with upstream since Ubuntu file appears to have
+    diff applied twice, causing redefines.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Fri, 17 Jun 2011 09:59:49 +0100
+
+upstart (1.3-0ubuntu2) oneiric; urgency=low
+
+  * init/Makefile.am: Sync up from upstream, dropping TEST define which is
+    no longer required now we set UPSTART_NO_SESSIONS for init/tests/*.c
+    and specify "--no-sessions" for util/tests/*.c.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Fri, 17 Jun 2011 09:47:36 +0100
+
+upstart (1.3-0ubuntu1) oneiric; urgency=low
+
+  * Merge of Upstart 1.3 (lp:upstart @ 1.3 release tag).
+
+ -- James Hunt <james.hunt@ubuntu.com>  Thu, 16 Jun 2011 15:09:41 +0100
+
+upstart (0.9.7-3) oneiric; urgency=low
+
+  * Merge of upstream lp:~upstart-devel/upstart/0.9: Updates for
+    init-checkconf.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Wed, 27 Apr 2011 15:19:47 +0100
+
+upstart (0.9.7-2) oneiric; urgency=low
+
+  * Add wait-for-state generic "wait job".
+
+ -- Clint Byrum <clint@ubuntu.com>  Wed, 04 May 2011 08:32:04 -0700
+
+upstart (0.9.7-1) natty; urgency=low
+
+  * New upstream release 0.9.7: Important session fix (LP: #767053).
+
+ -- James Hunt <james.hunt@ubuntu.com>  Wed, 20 Apr 2011 17:44:41 +0100
+
+upstart (0.9.6-1ubuntu1) natty; urgency=low
+
+  [ James Hunt ]
+  * init/man/init.5: Remove mention of user jobs since facility is
+  disabled.
+
+  [ Clint Byrum ]
+  * Noting bugs fixed by 0.9.6 release of upstart: (LP: #728531 , LP: #766206)
+
+ -- Clint Byrum <clint@ubuntu.com>  Tue, 19 Apr 2011 13:16:46 -0700
+
+upstart (0.9.6-1) natty; urgency=low
+
+  * New upstream release 0.9.6: Important session+chroot fixes.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Fri, 15 Apr 2011 15:36:40 +0100
+
+upstart (0.9.5-1ubuntu1) natty; urgency=low
+
+  [ Clint Byrum ]
+  * debian/upstart-job: change behavior to reload job configuration on
+    restart, which more closely matches expected sysvinit script
+    behavior. (LP: #707479)
+
+ -- James Hunt <james.hunt@ubuntu.com>  Wed, 06 Apr 2011 17:50:53 +0100
+
+upstart (0.9.5-1) natty; urgency=low
+
+  * New upstream release 0.9.5.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Wed, 06 Apr 2011 17:45:38 +0100
+
+upstart (0.9.4-1ubuntu1) natty; urgency=low
+
+  * debian/manpages/upstart-events.7:
+    - Corrected reference to Upstart man page (actually init).
+    - Changed to using proper troff quotes.
+    - Escaped dashes in event names.
+    - Updated date.
+    - Table 1:
+      - Improved name.
+      - Sorted columns: Events, References, and Notes.
+      - Added unmounted-remote-filesystems event. 
+
+ -- James Hunt <james.hunt@ubuntu.com>  Thu, 24 Mar 2011 14:34:12 +0000
+
+upstart (0.9.4-1) natty; urgency=low
+
+  * New upstream release 0.9.4:
+    - scripts/initctl2dot.py: Fixes to handle 'emits' glob syntax.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Thu, 24 Mar 2011 14:31:26 +0000
+
+upstart (0.9.3-1) natty; urgency=low
+
+  * New upstream release 0.9.3:
+    - Added missing emits stanzas for supplied .conf files.
+    - Added wildcard/globbing facility to initctl.c (for check-config
+      command).
+    - Updated man page on emits stanza syntax.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Tue, 15 Mar 2011 11:57:11 +0000
+
+upstart (0.9.2-1) natty; urgency=low
+
+  * Merge of upstream lp:~upstart-devel/upstart/0.9.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Fri, 11 Mar 2011 10:34:39 +0000
+
+upstart (0.9.1-1ubuntu5) natty; urgency=low
+
+  * Merge of upstream lp:~upstart-devel/upstart/0.9. 
+
+ -- James Hunt <james.hunt@ubuntu.com>  Thu, 10 Mar 2011 14:23:28 +0000
+
+upstart (0.9.1-1ubuntu4) natty; urgency=low
+
+  * Merge of upstream lp:~upstart-devel/upstart/0.9.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Mon, 07 Mar 2011 15:08:35 +0000
+
+upstart (0.9.1-1ubuntu3) natty; urgency=low
+
+  * debian/upstart.bash-completion: Fixed path so dh_bash-completion
+    considers it a file, not a snippet.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Fri, 04 Mar 2011 21:26:27 +0000
+
+upstart (0.9.1-1ubuntu2) natty; urgency=low
+
+  * debian/control: Added Suggests for python, graphviz and
+    bash-completion.
+  * debian/rules: Invoke bash-completion add-on explicitly.
+  * debian/manpages/upstart-events.7: New man page.
+  * debian/upstart.bash-completion: Install bash completion.
+  * debian/upstart.manpages: Install upstart-events.7.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Fri, 04 Mar 2011 17:16:26 +0000
+
+upstart (0.9.1-1ubuntu1) natty; urgency=low
+
+  * Merge of upstream lp:~upstart-devel/upstart/0.9.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Fri, 04 Mar 2011 15:13:35 +0000
+
+upstart (0.9.1-1) natty; urgency=low
+
+  * Merge of upstream lp:~upstart-devel/upstart/0.9.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Thu, 03 Mar 2011 20:52:16 +0000
+
+upstart (0.9.0-1ubuntu3) natty; urgency=low
+
+  * Revert dbus/Upstart.conf to the version in 0.6.7, disabling user session
+    support until such time as it has comprehensive test suite coverage.
+
+ -- Colin Watson <cjwatson@ubuntu.com>  Mon, 28 Feb 2011 20:29:01 +0000
+
+upstart (0.9.0-1ubuntu2) natty; urgency=low
+
+  * Added extra/Makefile.in to avoid build failing. These files need removing
+    at a later date and debian/rules updating to call dh-autoreconf.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Thu, 24 Feb 2011 16:39:28 +0000
+
+upstart (0.9.0-1ubuntu1) natty; urgency=low
+
+  * debian/control: Updated for nih version 1.0.3 (required for nih-dbus-tool
+    and DBUS_TYPE_UNIX_FD).
+  * removed binary message catalog files causing build issues:
+    - po/en@boldquot.gmo
+    - po/en@quot.gmo
+
+ -- James Hunt <james.hunt@ubuntu.com>  Thu, 24 Feb 2011 16:06:13 +0000
+
+upstart (0.9.0-1) natty; urgency=low
+
+  * New upstream release:
+    - Session support (chroots, sessions and user-session).
+    - Socket bridge.
+    - Override file support.
+
+ -- James Hunt <james.hunt@ubuntu.com>  Thu, 24 Feb 2011 14:22:14 +0000
+
+upstart (0.6.7-7) natty; urgency=low
+
+  * Re-add upstream r977 to allow proper re-exec on shutdown (LP: #672177)
+  * debian/control: adding Breaks on eglibc version that disables 
+    telinit u to avoid accidentally installing a version of libc6 that 
+    will cause upstart to re-exec and lose its state.
+
+ -- Clint Byrum <clint@ubuntu.com>  Fri, 21 Jan 2011 08:39:13 -0800
+
+upstart (0.6.7-6) natty; urgency=low
+
+  * debian/apparmor-profile-load: check for correct AppArmor profile loading
+    interface file (LP: #710649).
+
+ -- Kees Cook <kees@ubuntu.com>  Thu, 03 Feb 2011 13:45:32 -0800
+
+upstart (0.6.7-5) natty; urgency=low
+
+  * debian/upstart-job: properly handle jobs that are in state 'start/running'
+    with no PID, by checking only if the goal is 'start'.  LP: #603934,
+    #707971.
+
+ -- Steve Langasek <steve.langasek@ubuntu.com>  Wed, 26 Jan 2011 14:05:43 -0800
+
+upstart (0.6.7-4) natty; urgency=low
+
+  * debian/apparmor-profile-load: allow profiles to be missing for saner
+    packaging integration.
+
+ -- Kees Cook <kees@ubuntu.com>  Fri, 14 Jan 2011 13:46:12 -0800
+
+upstart (0.6.7-3) natty; urgency=low
+
+  * debian/rules: make sure apparmor-profile-load is executable.
+
+ -- Kees Cook <kees@ubuntu.com>  Wed, 22 Dec 2010 10:55:09 -0800
+
+upstart (0.6.7-2) natty; urgency=low
+
+  * debian/apparmor-profile-load: common AppArmor profile loading helper
+    which can be used by any upstart services, regardless of the state
+    of AppArmor (LP: #692801).
+
+ -- Kees Cook <kees@ubuntu.com>  Mon, 20 Dec 2010 16:03:33 -0800
+
+upstart (0.6.7-1) natty; urgency=low
+
+  * New upstream release:
+    - Added manual stanza.
+    - Added debug stanza.
+    - Added start_on, stop_on and emits properties.
+    - Added GoalChanged, StateChanged and Failed signals.
+    - Documentation updates.
+
+  * Added myself as a maintainer. 
+
+ -- James Hunt <james.hunt@ubuntu.com>  Tue, 14 Dec 2010 17:15:57 +0000
+
+upstart (0.6.6-3) maverick; urgency=low
+
+  * Ubuntu seems to have stopped installing Recommends of Build-Depends,
+    add a Build-Depend on dbus.  LP: #602130.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Thu, 12 Aug 2010 16:38:05 -0400
+
+upstart (0.6.6-2) maverick; urgency=low
+
+  * Apply patch from trunk to use /dev/null when /dev/console is unavailable
+    due to kernel bugs.  This isn't a fix for those bugs, but it does work
+    around it for now.  LP: #554172.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Thu, 12 Aug 2010 09:52:07 -0400
+
+upstart (0.6.6-1ubuntu1) maverick; urgency=low
+
+  * Try buying with -fPIE/-pie on armel again; we have a shiny new armel
+    toolchain and this part of the rules was broken in 0.6.6-1 anyway.
+
+ -- Loïc Minier <loic.minier@ubuntu.com>  Fri, 23 Jul 2010 14:54:11 +0200
+
+upstart (0.6.6-1) maverick; urgency=low
+
+  * New upstream release:
+    - All changes were previously merged into this package.
+
+  * debian/upstart-job:
+    - Fix output for the force-reload command to only refer to reload(8).
+      LP: #532862.
+
+  * Add debian/source/format with "1.0" to be future compatible.
+  * Add missing ${misc:Depends}.
+  * Bump standards version.
+  * Convert rules to dh7 format.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Tue, 27 Apr 2010 13:41:18 -0700
+
+upstart (0.6.5-6) lucid; urgency=low
+
+  * Merge fixes from trunk:
+    - double-quoting of NIH_CFLAGS and NIH_DBUS_CFLAGS on --with-local-libnih
+    - document "env KEY" behaviour
+  * conf/rc.conf, conf/rc-sysinit.conf:
+    - enable console output.  LP: #548954.
+    - pass value of INIT_VERBOSE from kernel command-line. 
+
+ -- Scott James Remnant <scott@ubuntu.com>  Thu, 01 Apr 2010 19:25:36 +0100
+
+upstart (0.6.5-5) lucid; urgency=low
+
+  * init/main.c:
+    - Don't change the settings of the foreground console, this is often
+      owned by plymouth and not supposed to be in Canonical Mode; all other
+      paths have stty sane settings anyway (which these are not), so there
+      really isn't need for init to do this.  LP: #540256.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed, 17 Mar 2010 22:34:55 +0000
+
+upstart (0.6.5-4) lucid; urgency=low
+
+  * debian/control:
+    - change Pre-Depends back to Depends, this was a holdover from when we
+      attempted to make Upstart Essential to solve early sysvinit→upstart
+      upgrade issues, we backed out the Essential bit but never the use of
+      Pre-Depends.  LP: #527722.
+    - add versioned-dependencies on ifupdown for loopback fix that can
+      prevent initscripts from being run.  LP: #527830.
+
+  * Merge patches from trunk to use /proc/self/fd instead of /dev/fd, and
+    to always mount /proc and /sys on boot.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Fri, 26 Feb 2010 15:40:58 +0000
+
+upstart (0.6.5-3) lucid; urgency=low
+
+  * udev/upstart-udev-bridge.c: use right variable name, fixing a build
+    failure. (LP: #524484)
+
+ -- Scott Moser <smoser@ubuntu.com>  Fri, 19 Feb 2010 10:21:33 -0500
+
+upstart (0.6.5-2) lucid; urgency=low
+
+  * udev/upstart-udev-bridge.c:
+    - Increase receiving buffer size for uevents so we don't miss any.
+      LP: #504883.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed, 17 Feb 2010 15:50:40 +0000
+
+upstart (0.6.5-1) lucid; urgency=low
+
+  * New upstream release:
+    - libnih has been separated out into its own project.
+    - "start on" and "stop on" now support != matches.  LP: #513035.
+    - Fixed crash in child when unable to spawn job.  LP: #451917.
+    - No longer holds /dev/console open so SAK won't kill init.  LP: #486005.
+    - Added missing OPTIONS section to init(8).  LP: #449883.
+
+  [ Scott James Remnant ]
+  * Build-depend on libnih-dev, libnih-dbus-dev and nih-dbus-tool to use
+    the separated out libnih.
+    - This has the fix for LP: #436758.
+    - Remove changelog.nih from the doc directory.
+  * Bump udev build-dependency to 147 to match upstream.
+  * udev/Makefile.am: Update to use external libnih
+
+  [ Johan Kiviniemi ]
+  * udev/upstart-udev-bridge.c: Change -device-remove to -device-removed to
+    match -device-added and -device-changed.  LP: #516698.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Thu, 04 Feb 2010 16:30:10 -0800
+
+upstart (0.6.3-11build1) lucid; urgency=low
+
+  * Rebuild to pick up relaxed dependency on libc6, after checking that
+    __abort_msg is available with the same signature in eglibc 2.11.
+   LP: #508702.
+
+ -- Matthias Klose <doko@ubuntu.com>  Mon, 18 Jan 2010 16:10:11 +0100
+
+upstart (0.6.3-11) karmic-proposed; urgency=low
+
+  * Make rc-sysinit.conf wait on the loopback interface, to ensure that the
+    interface is up before we process the scripts in /etc/rc?.d.  LP: #461725.
+
+ -- Steve Langasek <steve.langasek@ubuntu.com>  Tue, 08 Dec 2009 12:58:37 -0800
+
+upstart (0.6.3-10) karmic; urgency=low
+
+  * Retain the "telinit u" for the case when we're upgrading from pre-0.6
+    (ie. hardy or jaunty).  Whups.  LP: #451556.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Thu, 15 Oct 2009 17:48:47 +0100
+
+upstart (0.6.3-9) karmic; urgency=low
+
+  * Restore the call to sync() in reboot, have been observing some issues
+    and it looks like ext4 might not be explicitly flushing the disk when
+    remounting read-only.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed, 14 Oct 2009 16:40:32 +0100
+
+upstart (0.6.3-8) karmic; urgency=low
+
+  * Rather than calling "telinit u" after upgrade, which will lose state,
+    have the umountroot initscript take care of it for us by setting a
+    flag.  LP: #441796.
+  * Don't lose the original default runlevel if /etc/inittab exists without
+    an initdefault line.  LP: #405847.
+  * Fix "unhandled error" in shutdown when unable to change runlevel,
+    e.g. due to previous Ubiquity bug.  LP: #426332.
+  * Merge change from trunk that makes it possible to build Upstart using
+    a previously built copy of nih-dbus-tool, especially useful when
+    cross-compiling.  LP: #426740.
+  * Merge change from libnih to store our assertion messages in the
+    glibc __abort_msg symbol so apport can pick them up.  LP: #429411.
+  * Merge change from libnih to fix compilation issue with eglibc due
+    to changed alphasort() prototype.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed, 14 Oct 2009 05:34:13 +0100
+
+upstart (0.6.3-7) karmic; urgency=low
+
+  * Ignore initramfs pids that don't exist.  LP: #440071.
+    - you still need to ensure that the pid's parent is init, there's no
+      cheap way to test for that. 
+  * Remove "console owner" and "console output" from rc scripts.
+  * Try harder to remove dbus-reconnect.conf
+
+ -- Scott James Remnant <scott@ubuntu.com>  Fri, 02 Oct 2009 21:09:03 +0100
+
+upstart (0.6.3-6) karmic; urgency=low
+
+  * Don't use "telinit q" to reconnect to D-Bus, since that breaks
+    lots of things.  Invent another secret way instead.
+
+  [ Steve Langasek ]
+  * upstart-job's restart target must also not fail when the service is not
+    yet started.  LP: #430883.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Thu, 01 Oct 2009 15:26:19 +0100
+
+upstart (0.6.3-5) karmic; urgency=low
+
+  * Update autoconf and automake files.  LP: #435252.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed, 23 Sep 2009 14:16:34 -0700
+
+upstart (0.6.3-4) karmic; urgency=low
+
+  [ Scott James Remnant ]
+  * Reduce the priority of the stopped by/continued by messages so that
+    they are only shown when --verbose on the kernel command-line.
+    LP: #401333.
+  * Add a hack to look for /dev/.initramfs/*.pid files on startup and
+    "fake" start jobs of those names.  Basically this means that "status"
+    and "stop" work for things like bootchart and usplash.
+  * Implement a "reload" command in initctl that retrieves the current pid
+    of the job and sends it the HUP signal.  LP: #433544.
+
+  [ Steve Langasek ]
+  * debian/upstart-job:
+    - give proper policy-compliant behavior of the start command: detect if
+      the job is already running using upstart status, and if so return success.
+    - same for the stop command: return success if the job is already stopped.
+    - when $DPKG_MAINTSCRIPT_PACKAGE is set, don't spit warnings out because
+      it's not the user's fault - we're being invoked by a maintainer script.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Tue, 22 Sep 2009 13:56:48 -0700
+
+upstart (0.6.3-3) karmic; urgency=low
+
+  * debian/upstart-job:
+    - force-reload should only send a HUP signal, since it may not be wise
+      to actually restart (cf. dbus)
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed, 16 Sep 2009 00:10:13 +0100
+
+upstart (0.6.3-2) karmic; urgency=low
+
+  FFE LP: #427356.
+
+  * debian/upstart-job:
+    - Remove trailing "s" from file
+    - Support direct invocation better.
+  * udev/upstart-udev-bridge.c:
+    - New tool to capture events from the udev netlink socket and
+      convert into upstart events.
+  * conf/rc-sysinit.conf:
+    - Run once all filesystems are mounted, rather than on startup
+  * debian/control:
+    - Add dependency on mountall for the filesystem event.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Tue, 15 Sep 2009 03:19:09 +0100
+
+upstart (0.6.3-1) karmic; urgency=low
+
+  * New upstream release:
+    - Fixed assertion when a job exits while stopping.  LP: #406408.
+    - Fixed compilation on ia64.
+    - nih-dbus-tool(1) manpage no longer installed.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Mon, 03 Aug 2009 23:58:47 +0100
+
+upstart (0.6.2-1) karmic; urgency=low
+
+  * New upstream release:
+    - Fixed assertion when stopping a job during its starting event.
+    - Fixed fork following to not stop on exec() before fork()
+    - Fixed missing chdir() in crash handler.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed, 22 Jul 2009 10:39:50 +0100
+
+upstart (0.6.1-1) karmic; urgency=low
+
+  * New upstream release:
+    - Fixed race condition in ptrace() code.  LP: #264711.
+    - Fixed runlevel to output "unknown" not "N N".  LP: #400248.
+    - Fixed runlevel to prefix error messages with filename.  LP: #400241.
+
+  * Provide/Conflict/Replace the agreed "upstart-job" meta-package.
+    LP: #399799.
+  * Bump dpkg dependency to 1.2.16
+
+ -- Scott James Remnant <scott@ubuntu.com>  Thu, 16 Jul 2009 18:26:23 +0100
+
+upstart (0.6.0-5) karmic; urgency=low
+
+  * Cherry-pick patch from -r1188 to fix "expect fork" and "expect daemon"
+    LP: #264711.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Tue, 14 Jul 2009 15:19:17 +0100
+
+upstart (0.6.0-4) karmic; urgency=low
+
+  * Don't build the testsuite with -fPIE on armel; LP: #398403.
+
+ -- Loïc Minier <lool@dooz.org>  Mon, 13 Jul 2009 22:12:34 +0200
+
+upstart (0.6.0-3) karmic; urgency=low
+
+  * Add Conflicts on older Upstart packages to make update-manager's
+    job easier.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Fri, 10 Jul 2009 10:11:21 +0100
+
+upstart (0.6.0-2) karmic; urgency=low
+
+  * Bump D-Bus build dependency to ensure we get the container abandonment
+    patches, and the GIT version bump.
+  * Actually ship /lib/init/upstart-job
+
+ -- Scott James Remnant <scott@ubuntu.com>  Thu, 09 Jul 2009 17:29:59 +0100
+
+upstart (0.6.0-1) karmic; urgency=low
+
+  * New upstream release ("How appropriate, you fight like a cow")
+    - my customary changes list since pointless, it's basically a
+      complete rewrite.
+    - Handles /bin/sh symlink disappearing.  LP: #65024.
+    - Boot parameters may be passed to init scripts.  LP: #74664.
+    - reboot implies --force during shutdown.  LP: #388738.
+    - reboot no longer iterates /proc/ide.  LP: #92685.
+    - much improved documentation.  LP: #60429, #72058, #388715.
+
+  * Merge the various upstart packages into a single package, it makes
+    little sense to have it all spread out.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed, 08 Jul 2009 23:12:03 +0100
+
+upstart (0.3.10-2) karmic; urgency=low
+
+  * debian/upstart.postinst: Use telinit u to re-exec, rather than
+    kill just in case it's not Upstart that's running.  LP: #92177. 
+  * debian/event.d/system-services/tty*: Run getty in 8-bit clean
+    mode.  LP: #273189. 
+  * debian/event.d/upstart-compat-sysv/rc-default:
+    - Don't use grep -w, instead split on $IFS and iterate.  LP: #385911.
+    - Check for any valid runlevel, not just S.  LP: #85014.
+    - Make console owner, since it may spawn sulogin.
+  * debian/event.d/upstart-compat-sysv/rcS: 
+    - Spawn sulogin if given -b or "emergency".  LP: #193810.
+  * debian/event.d/upstart-compat-sysv/rcS:
+    - Make console owner.  LP: #211402.
+  * debian/event.d/upstart-compat-sysv/rcS-sulogin:
+    - Place the telinit code in post-stop, checking $UPSTART_EVENT first so
+      we don't change the runlevel if we were stopped due to a runlevel
+      change.  LP: #66002.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Thu, 18 Jun 2009 16:19:34 +0100
+
+upstart (0.3.10-1) karmic; urgency=low
+
+  * Compilation fixes.
+  * Fixed assertion caused by the post-start or pre-stop scripts
+    exiting after the main process of a respawning job had exited.
+    LP: #381048.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed, 17 Jun 2009 13:33:40 +0100
+
+upstart (0.3.9-8) intrepid; urgency=low
+
+  * Do not attempt to continue communicating with the restarted upstart
+    (LP: #273761).
+
+ -- Kees Cook <kees@ubuntu.com>  Mon, 29 Sep 2008 13:35:21 -0700
+
+upstart (0.3.9-7) intrepid; urgency=low
+
+  * Implement "telinit u" by just sending Upstart SIGTERM with a slightly
+    different patch than Fedora.  LP: #188925.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Tue, 23 Sep 2008 09:01:09 -0700
+
+upstart (0.3.9-6) intrepid; urgency=low
+
+  * Really fix LP: #237276 properly this time, lost the change while mucking
+    around with bzr.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed, 04 Jun 2008 22:29:48 +0100
+
+upstart (0.3.9-5) intrepid; urgency=low
+
+  * Correct build problem on amd64 and ia64 by only building libnih and
+    libupstart statically.  The shared objects were unwanted, and conflict
+    with -fPIE.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed, 04 Jun 2008 17:07:12 +0100
+
+upstart (0.3.9-4) intrepid; urgency=low
+
+  * Add missing limits.h, required to build with current libc.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed, 04 Jun 2008 13:09:32 +0100
+
+upstart (0.3.9-3) intrepid; urgency=low
+
+  * Change dependency from sysvutils to sysvinit-utils.  LP: #237276.
+  * Compile with stack -fstack-protector, -fPIE, -z relro, -z now and -pie
+    (MMmm, pie)
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed, 04 Jun 2008 12:59:11 +0100
+
+upstart (0.3.9-2) hardy; urgency=low
+
+  * Start the getty on tty1 after the rc script has stopped rather then
+    at the same time it starts to avoid overwriting by console messages.
+    tty2..6 will still be active if you want an early login.  LP: #65230.
+  * If the recovery menu is available start that instead of sulogin when
+    entering single-user-mode.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Fri, 11 Apr 2008 13:38:50 +0100
+
+upstart (0.3.9-1) hardy; urgency=low
+
+  * New upstream release:
+    - many bug fixes.
+
+  * Update reference to "edgy" in README.Debian to "hardy".  LP: #140037.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Sun, 28 Oct 2007 10:51:59 -0400
+
+upstart (0.3.8-2) gutsy; urgency=low
+
+  * Fix broken migration of old-style 'respawn process' stanzas which
+    produced corrupted 'exec' stanzas. Try to fix up files previously
+    corrupted by this. LP: #95210
+
+ -- Scott James Remnant <scott@ubuntu.com>  Sun, 28 Oct 2007 10:50:36 -0400
+
+upstart (0.3.8-1) feisty; urgency=low
+
+  * New upstream release:
+    - much improved initctl tool.
+
+  * Update my standard prep_/undo_/rm_conffile functions to take into account
+    current dpkg behaviour wrt obsolete conffiles.  The conffile is now moved
+    out of the way in preinst and the moved file deleted in postinst, or moved
+    back in postrm abort-upgrade.  This means it's not there when dpkg
+    configures the new version, so the conffile is not left in the list.
+  * Purge backups of modified obsolete conffiles when the package is purged.
+
+  * Update runlevel and respawn rule generated in migrate-inittab.pl
+    LP: #89314
+
+  * Drop 00-libnih-update.patch and 01-libnih-sparc-ftbfs.patch; new upstream
+    release includes an up-to-date libnih which contains both patches.
+  * Drop 10-cant-stop-execless-job.patch; included upstream.
+  * Drop 20-complex-event-config.patch; this is going to be significantly
+    changed upstream, and we don't want to ship something strange.
+  * Drop 30-fix-warnings.patch; included upstream.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Sun, 11 Mar 2007 19:19:00 +0000
+
+upstart (0.3.5-2) feisty; urgency=low
+
+  * Changed "start script" to "pre-start script" in sulogin event, the former
+    is no longer recognised.
+
+  * Applied 01-libnih-sparc-ftbfs.patch; this updates the signal name list
+    to exclude signals not available on that architecture, and add one that's
+    unique to it.
+  * Applied 30-fix-warnings.patch; this corrects a few warnings that spoiled
+    an otherwise clean build log.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Tue, 13 Feb 2007 15:56:33 +0000
+
+upstart (0.3.5-1) feisty; urgency=low
+
+  * New upstream release:
+    - inotify file descriptor leak fixed.  LP: #83099.
+    - inotify support is no longer required.  LP: #68904.
+    - new job state machine
+    - new event structure, can now include arguments and environment
+
+  * Applied 00-libnih-update.patch; this updates the libnih library to the
+    latest bzr trunk version, required for the complex-event-config patch.
+  * Applied 10-cant-stop-execless-job.patch from upstream; this corrects a
+    bug where jobs without an "exec" or "script" stanza cannot be stopped.
+  * Applied 20-complex-event-config.patch from upstream; this is an
+    experimental implementation of the "on" keyword that allows definition
+    of complex system states.
+
+  * System V compatibility jobs updated to match new event names.
+  * rcS job now sets PREVLEVEL and RUNLEVEL.  LP: #76304.
+
+  * NOTE: After this upgrade, init will appear to have "forgotten" the
+    process ids of your gettys, etc.  This is not a critical problem and
+    will be fixed before release.  Shutdown will still work as normal.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Mon, 12 Feb 2007 13:51:40 +0000
+
+upstart (0.3.1-1) feisty; urgency=low
+
+  * New upstream release:
+    - start, stop and status are now symlinks to initctl, not to a
+      different, separate utility.
+    - initctl completely rewritten to behave properly.
+    - some upstart-specific options to shutdown and reboot dropped, as
+      these are considered SysV-compat tools.
+    - "console none" fixed.  LP: #70782.
+    - improved documentation.  LP: #68805.
+
+  * shutdown and reboot moved to upstart-compat-sysv.
+
+  * Replace the /usr/share/doc/* directory in upstart-logd,
+    upstart-compat-sysv, system-services and startup-tasks with a symlink to
+    /usr/share/doc/upstart.  This was actually done in a previous package,
+    but the migration missed.  LP: #70895.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed, 13 Dec 2006 17:27:37 +0000
+
+upstart (0.2.7-7) edgy; urgency=low
+
+  * Don't abort the postinst if we can't send init SIGTERM.  Ubuntu: #64499.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Tue, 10 Oct 2006 10:13:05 +0100
+
+upstart (0.2.7-6) edgy; urgency=low
+
+  * Don't start gettys on tty2 thru tty6 in runlevels 4 and 5 (matches
+    our sysvinit configuration).
+  * Migrate common changes made to /etc/inittab to /etc/event.d by
+    adjusting the installed conffiles.  Ubuntu: #61539.
+
+  * Include missing AUTHORS and NEWS file in the upstart package.
+  * Include README.Debian which answers common questions.  Ubuntu: #60429.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Thu,  5 Oct 2006 16:08:34 +0100
+
+upstart (0.2.7-5) edgy; urgency=low
+
+  * Don't set the current runlevel in /var/run/utmp to 0 or 6 if it is
+    already either of those two values.  That way we don't end up with
+    either 0 or 6 in the PREVLEVEL variable, which can cause
+    /etc/init.d/rc to be "efficient" and not bother doing
+    anything.  Ubuntu: #63852.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed,  4 Oct 2006 14:06:18 +0100
+
+upstart (0.2.7-4) edgy; urgency=low
+
+  * Can't just start rc-default once in single-user mode, because if we
+    boot into that, that will just return us back to sulogin again.  Copy
+    the script out of rc-default into rcS-sulogin to call telinit with the
+    right default runlevel.  Ubuntu: #62189.
+
+  * Add Build-Depend on dpkg-dev (>= 1.13.19) due to our use of
+    ${binary:Version}.  Ubuntu: #61693.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Tue, 26 Sep 2006 17:20:42 +0100
+
+upstart (0.2.7-3) edgy; urgency=low
+
+  * Set the runlevel to "S" when we enter sulogin so that it appears
+    in utmp.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Thu, 21 Sep 2006 05:37:25 +0100
+
+upstart (0.2.7-2) edgy; urgency=low
+
+  * Ensure that the same version of upstart is installed as the version of
+    upstart-compat-sysv and upstart-logd; as the IPC protocol may change
+    between releases.
+
+  * Adjust the rcS-sulogin job so that if sulogin exits the default runlevel
+    is entered; but if the job is stopped (e.g. by shutdown) it isn't.  The
+    solves the regression introduced in the previous release.
+
+  * Revert upstream logd/"quiet" change in favour of doing it in our
+    lsb logging functions instead; seems to work better (fsvo better).
+
+ -- Scott James Remnant <scott@ubuntu.com>  Thu, 21 Sep 2006 03:12:33 +0100
+
+upstart (0.2.7-1) edgy; urgency=low
+
+  * New upstream release:
+    - logd now writes to the console unless "quiet" is specified
+    - runaway jobs caught when they start rather than respawn.  Ubuntu: #59807
+
+  * Fix failure to shutdown while in single-user mode, however this means
+    that for edgy you can't exit the sulogin shell to enter the default
+    runlevel; explicitly say what works.  Ubuntu: #60626.
+  * Drop unnecessary dependency on util-linux.
+  * Drop sulogin hack, instead depend on the version of sysvutils that
+    includes the real one.  Ubuntu: #60965.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed, 20 Sep 2006 05:39:16 +0100
+
+upstart (0.2.6-1) edgy; urgency=low
+
+  * New upstream release:
+    - fix infinite loop caused by bad waitid() call.  Ubuntu: #59459.
+    - halt now behaves as "shutdown -h now".  Ubuntu: #59720.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed, 13 Sep 2006 22:16:17 +0100
+
+upstart (0.2.5-1) edgy; urgency=low
+
+  * New upstream release:
+    - no longer spins when no stalled event handler.  Ubuntu: #59170.
+    - shutdown works when under sysvinit.  Ubuntu: #58523;
+    - shutdown -k implemented.  Ubuntu: #58723.
+    - telinit sends shutdown event for 0, 1 and 6.  Ubuntu: #58913.
+    - basic manual pages included.  Ubuntu: #58724.
+
+  * upstart-compat-sysv Replaces: sysvinit.  Ubuntu: #59427.
+  * upstart Recommends: upstart-compat-sysv, startup-tasks & system-services.
+
+  * New upstart-logd package includes the logd daemon that can will log
+    output of jobs with "console logged" (the default) in their description
+    to /var/log/boot.
+
+  * Add /etc/event.d/rc0 that is run on the "halt" event (neither -H or -P
+    given), and modify rc0-halt to run on "system-halt" (-H given) and
+    rc0-poweroff to run on "power-off" (-P given).  Ubuntu: #59134.
+  * Fix the control-alt-delete job to run on the "ctrlaltdel" event so
+    that it's triggered properly.  Ubuntu: #59398.
+  * Fix single-user mode.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Sat,  9 Sep 2006 05:10:12 +0100
+
+upstart (0.2.1-7) edgy; urgency=low
+
+  * Remove the Essential tags again, they didn't solve the problem we
+    hoped they would (dpkg/apt still won't remove sysvinit without
+    serious persuasion) and I don't think these packages should be.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Thu,  7 Sep 2006 02:42:33 +0100
+
+upstart (0.2.1-6) edgy; urgency=low
+
+  * Make packages Essential, and change Depends to Pre-Depends so that the
+    packages work when unconfigured (nothing interesting is performed in
+    postinst).  Ubuntu: #59005.
+  * Sync priority in debian/control with that in the archive (required)
+  * Drop warning of dire consequences if you install upstart, seeing as it's
+    installed by default.
+
+  * Add new startup-tasks and system-services packages which will contain
+    the /etc/event.d files themselves (other than the main ones).
+  * Move tty definitions into system-services.
+  * Modify tty definitions to start when the rcS task has finished.  This
+    puts them in the "right" place when compared to gdm.  Ubuntu: #58630.
+
+  * Correct rcS compatibility script to ignore any information in utmp so
+    that all scripts are always run.  Ubuntu: #59203.
+  * Make rcS the console owner while it runs, temporary fix for
+    Ubuntu: #58609, #58794, #58796
+  * Include default control-alt-delete handler that reboots the machine.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Wed,  6 Sep 2006 21:52:48 +0100
+
+upstart (0.2.1-5) edgy; urgency=low
+
+  * upstart-compat-sysv Depends: initscripts (closes: Malone #58979).
+
+ -- Colin Watson <cjwatson@ubuntu.com>  Tue,  5 Sep 2006 12:22:50 +0100
+
+upstart (0.2.1-4) edgy; urgency=low
+
+  * Add missing #! line to top of postrm
+
+ -- Scott James Remnant <scott@ubuntu.com>  Mon,  4 Sep 2006 08:11:16 +0100
+
+upstart (0.2.1-3) edgy; urgency=low
+
+  * Remove the rc0 configuration file shipped in 0.1.0 that causes all
+    reboots to become shutdowns.  Ubuntu: #58557.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Sun,  3 Sep 2006 23:24:41 +0100
+
+upstart (0.2.1-2) edgy; urgency=low
+
+  * Don't send the SIGTERM signal unless we're upgrading from a version
+    of upstart that supports re-exec; older versions would cause a kernel
+    PANIC and change from sysvinit does nothing.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Sat,  2 Sep 2006 17:18:38 +0100
+
+upstart (0.2.1-1) edgy; urgency=low
+
+  * New upstream release:
+    - compilation fixes.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Fri,  1 Sep 2006 19:51:41 +0100
+
+upstart (0.2.0-1) edgy; urgency=low
+
+  * New upstream release:
+    - upstart includes shutdown, reboot, halt, poweroff, start, stop, status,
+      runlevel and telinit utilities.
+    - "initctl list" will list active jobs.
+    - Events vastly simplified to just simple strings.
+  
+  * Compatibility tasks for old rc scripts, along with runlevel and telinit
+    utilities now shipped in upstart-compat-sysv package.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Fri,  1 Sep 2006 02:38:44 +0100
+
+upstart (0.1.1-1) edgy; urgency=low
+
+  * New upstream release:
+    - set PATH and TERM in processes
+
+ -- Scott James Remnant <scott@ubuntu.com>  Fri, 25 Aug 2006 16:17:52 +0200
+
+upstart (0.1.0-2) edgy; urgency=low
+
+  * Oops, rename /sbin/init to /sbin/upstart as documented.  Lost this
+    while battling bzr.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Thu, 24 Aug 2006 16:30:54 +0200
+
+upstart (0.1.0-1) edgy; urgency=low
+  
+  * Initial release.
+  
+ -- Scott James Remnant <scott@ubuntu.com>  Thu, 24 Aug 2006 14:27:47 +0200
--- upstart-1.5.orig/debian/compat
+++ upstart-1.5/debian/compat
@@ -0,0 +1 @@
+9
--- upstart-1.5.orig/debian/conf/console.conf
+++ upstart-1.5/debian/conf/console.conf
@@ -0,0 +1,11 @@
+# console - getty
+#
+# This service maintains a getty on console from the point the system is
+# started until it is shut down again.
+
+start on stopped rc RUNLEVEL=[2345] and container CONTAINER=lxc
+
+stop on runlevel [!2345]
+
+respawn
+exec /sbin/getty -8 38400 console
--- upstart-1.5.orig/debian/conf/container-detect.conf
+++ upstart-1.5/debian/conf/container-detect.conf
@@ -0,0 +1,42 @@
+description "Track if upstart is running in a container"
+
+start on mounted MOUNTPOINT=/run
+
+env container
+env LIBVIRT_LXC_UUID
+
+emits container
+emits not-container
+
+pre-start script
+    # The "standard" way of telling if we are in a container
+    # is to check for "container" in init's environment.
+    # The code below is for cases where it's not set.
+
+    # Detect old-style libvirt
+    if [ -z "$container" ]; then
+        [ -n "$LIBVIRT_LXC_UUID" ] && container=lxc-libvirt
+    fi
+
+    # Detect OpenVZ containers
+    if [ -z "$container" ]; then
+        [ -d /proc/vz ] && [ ! -d /proc/bc ] && container=openvz
+    fi
+
+    # Detect Vserver containers
+    if [ -z "$container" ]; then
+        VXID="$(cat /proc/self/status | grep ^VxID | cut -f2)" || true
+        [ "${VXID:-0}" -gt 1 ] && container=vserver
+    fi
+
+    if [ -n "$container" ]; then
+        echo "$container" > /run/container_type || true
+        initctl emit --no-wait container CONTAINER=$container
+        exit 0
+    fi
+
+    # If not a container, stop there
+    rm -f /run/container_type
+    initctl emit --no-wait not-container
+    stop
+end script
--- upstart-1.5.orig/debian/conf/failsafe.conf
+++ upstart-1.5/debian/conf/failsafe.conf
@@ -0,0 +1,44 @@
+# failsafe
+
+description "Failsafe Boot Delay"
+author "Clint Byrum <clint@ubuntu.com>"
+
+start on filesystem and net-device-up IFACE=lo
+stop on static-network-up or starting rc-sysinit
+
+emits failsafe-boot
+
+console output
+
+script
+	# Determine if plymouth is available
+	if [ -x /bin/plymouth ] && /bin/plymouth --ping ; then
+		PLYMOUTH=/bin/plymouth
+	else
+		PLYMOUTH=":"
+	fi
+
+    # The point here is to wait for 2 minutes before forcibly booting 
+    # the system. Anything that is in an "or" condition with 'started 
+    # failsafe' in rc-sysinit deserves consideration for mentioning in
+    # these messages. currently only static-network-up counts for that.
+
+	sleep 20
+
+    # Plymouth errors should not stop the script because we *must* reach
+    # the end of this script to avoid letting the system spin forever
+    # waiting on it to start.
+	$PLYMOUTH message --text="Waiting for network configuration..." || :
+	sleep 40
+
+	$PLYMOUTH message --text="Waiting up to 60 more seconds for network configuration..." || :
+	sleep 59
+	$PLYMOUTH message --text="Booting system without full network configuration..." || :
+
+    # give user 1 second to see this message since plymouth will go
+    # away as soon as failsafe starts.
+	sleep 1
+    exec initctl emit --no-wait failsafe-boot
+end script
+
+post-start exec	logger -t 'failsafe' -p daemon.warning "Failsafe of 120 seconds reached."
--- upstart-1.5.orig/debian/conf/flush-early-job-log.conf
+++ upstart-1.5/debian/conf/flush-early-job-log.conf
@@ -0,0 +1,11 @@
+# flush-early-job-log - Ensure cached output from jobs that finish
+# before the disk is writeable are flushed to disk as soon as it does
+# becomes writeable.
+
+description "flush early job output to logs"
+
+task
+
+start on filesystem
+
+exec initctl notify-disk-writeable
--- upstart-1.5.orig/debian/conf/rcS.conf
+++ upstart-1.5/debian/conf/rcS.conf
@@ -0,0 +1,28 @@
+# rcS - System V single-user mode compatibility
+#
+# This task handles the old System V-style single-user mode, this is
+# distinct from the other runlevels since running the rc script would
+# be bad.
+
+description	"System V single-user mode compatibility"
+author		"Scott James Remnant <scott@netsplit.com>"
+
+start on runlevel S
+stop on runlevel [!S]
+
+console owner
+script
+    exec /sbin/sulogin
+end script
+
+post-stop script
+    # Don't switch runlevels if we were stopped by an event, since that
+    # means we're already switching runlevels
+    if [ -n "${UPSTART_STOP_EVENTS}" ]
+    then
+	exit 0
+    fi
+
+    # Switch, passing a magic flag
+    start --no-wait rc-sysinit FROM_SINGLE_USER_MODE=y
+end script
--- upstart-1.5.orig/debian/conf/shutdown.conf
+++ upstart-1.5/debian/conf/shutdown.conf
@@ -0,0 +1,9 @@
+# Trigger an immediate shutdown when upstart receives SIGPWR
+# this is useful for some UPS monitoring tools and for clean
+# shutdown of containers
+
+description "Trigger an immediate shutdown on SIGPWR"
+start on power-status-changed
+
+task
+exec shutdown -h now "SIGPWR received"
--- upstart-1.5.orig/debian/conf/tty1.conf
+++ upstart-1.5/debian/conf/tty1.conf
@@ -0,0 +1,14 @@
+# tty1 - getty
+#
+# This service maintains a getty on tty1 from the point the system is
+# started until it is shut down again.
+
+start on stopped rc RUNLEVEL=[2345] and (
+            not-container or
+            container CONTAINER=lxc or
+            container CONTAINER=lxc-libvirt)
+
+stop on runlevel [!2345]
+
+respawn
+exec /sbin/getty -8 38400 tty1
--- upstart-1.5.orig/debian/conf/tty2.conf
+++ upstart-1.5/debian/conf/tty2.conf
@@ -0,0 +1,14 @@
+# tty2 - getty
+#
+# This service maintains a getty on tty2 from the point the system is
+# started until it is shut down again.
+
+start on runlevel [23] and (
+            not-container or
+            container CONTAINER=lxc or
+            container CONTAINER=lxc-libvirt)
+
+stop on runlevel [!23]
+
+respawn
+exec /sbin/getty -8 38400 tty2
--- upstart-1.5.orig/debian/conf/tty3.conf
+++ upstart-1.5/debian/conf/tty3.conf
@@ -0,0 +1,14 @@
+# tty3 - getty
+#
+# This service maintains a getty on tty3 from the point the system is
+# started until it is shut down again.
+
+start on runlevel [23] and (
+            not-container or
+            container CONTAINER=lxc or
+            container CONTAINER=lxc-libvirt)
+
+stop on runlevel [!23]
+
+respawn
+exec /sbin/getty -8 38400 tty3
--- upstart-1.5.orig/debian/conf/tty4.conf
+++ upstart-1.5/debian/conf/tty4.conf
@@ -0,0 +1,14 @@
+# tty4 - getty
+#
+# This service maintains a getty on tty4 from the point the system is
+# started until it is shut down again.
+
+start on runlevel [23] and (
+            not-container or
+            container CONTAINER=lxc or
+            container CONTAINER=lxc-libvirt)
+
+stop on runlevel [!23]
+
+respawn
+exec /sbin/getty -8 38400 tty4
--- upstart-1.5.orig/debian/conf/tty5.conf
+++ upstart-1.5/debian/conf/tty5.conf
@@ -0,0 +1,11 @@
+# tty5 - getty
+#
+# This service maintains a getty on tty5 from the point the system is
+# started until it is shut down again.
+
+start on runlevel [23] and not-container
+
+stop on runlevel [!23]
+
+respawn
+exec /sbin/getty -8 38400 tty5
--- upstart-1.5.orig/debian/conf/tty6.conf
+++ upstart-1.5/debian/conf/tty6.conf
@@ -0,0 +1,11 @@
+# tty6 - getty
+#
+# This service maintains a getty on tty6 from the point the system is
+# started until it is shut down again.
+
+start on runlevel [23] and not-container
+
+stop on runlevel [!23]
+
+respawn
+exec /sbin/getty -8 38400 tty6
--- upstart-1.5.orig/debian/conf/wait-for-state.conf
+++ upstart-1.5/debian/conf/wait-for-state.conf
@@ -0,0 +1,60 @@
+author "Clint Byrum <clint.byrum@canonical.com>"
+description "Waiting for state"
+
+task
+normal exit 2
+
+stop on started $WAIT_FOR or stopped $WAIT_FOR
+
+# These are all arguments for use influencing how this job waits
+env TIMEOUT=30
+env MANUAL_OVERRIDE="N"
+env WAIT_FOREVER="N"
+env WAIT_STATE="started"
+env TARGET_GOAL="start"
+
+# Required args w/ no sensible default, the tests at the beginning of
+# the script are just to guard against WAITER="" or WAIT_FOR="", as the
+# instance line will fail if they are not set, since they have no env 
+instance $WAITER$WAIT_FOR
+
+script
+    test -n "$WAIT_FOR" || exit 1
+    test -n "$WAITER" || exit 1
+
+    # We don't want to override the manual stanza
+    # XXX: initctl show-config should share manual w/ us too
+    case $MANUAL_OVERRIDE in
+    N|n|0)
+        if grep -q "^\s*manual\s*$" /etc/init/$WAIT_FOR.conf ; then
+            exit 0
+        fi
+        ;;
+    esac
+
+    if [ "$WAIT_STATE" = "stopped" ] ; then
+        TARGET_GOAL="stop"
+    fi
+
+    # Already running/stopped?
+    status $WAIT_FOR | grep -q "$TARGET_GOAL/$WAIT_STATE" && exit 0
+
+    # Give it a push
+    $TARGET_GOAL $WAIT_FOR || :
+
+    # upstart will kill this shell on started/stopped $WAIT_FOR
+    while sleep $TIMEOUT ; do
+        case $WAIT_FOREVER in
+        N|n|0)
+            exit 100
+            ;;
+        Y|y|1)
+            ;;
+        *)
+            exit 1
+            ;;
+        esac
+    done
+    # Very strange, sleep returned non-zero?
+    exit 1
+end script
--- upstart-1.5.orig/debian/control
+++ upstart-1.5/debian/control
@@ -0,0 +1,22 @@
+Source: upstart
+Section: admin
+Priority: required
+Maintainer: James Hunt <james.hunt@ubuntu.com>
+Uploaders: Scott James Remnant <scott@ubuntu.com>
+Standards-Version: 3.8.4.0
+Build-Depends: debhelper (>= 9), pkg-config (>= 0.22), libnih-dev (>= 1.0.3), libnih-dbus-dev (>= 1.0.3), nih-dbus-tool (>= 1.0.3), libdbus-1-dev (>= 1.2.16), libexpat1-dev (>= 2.0.0), libudev-dev (>= 151-5), dbus, bash-completion
+Homepage: http://upstart.ubuntu.com/
+
+Package: upstart
+Architecture: any
+Depends: ${shlibs:Depends}, ${misc:Depends}, sysvinit-utils, sysv-rc, initscripts, mountall, ifupdown (>= 0.6.10ubuntu5)
+Suggests: python, graphviz, bash-completion
+Replaces: upstart-job, sysvinit, upstart-compat-sysv, startup-tasks, system-services
+Conflicts: upstart-job, sysvinit, upstart-compat-sysv, startup-tasks, system-services, lxcguest
+Provides: upstart-job, upstart-compat-sysv, startup-tasks, system-services
+Breaks: libc6 (<< 2.12.1-0ubuntu12), friendly-recovery (<< 0.2.13)
+Multi-Arch: foreign
+Description: event-based init daemon
+ upstart is a replacement for the /sbin/init daemon which handles
+ starting of tasks and services during boot, stopping them during
+ shutdown and supervising them while the system is running.
--- upstart-1.5.orig/debian/copyright
+++ upstart-1.5/debian/copyright
@@ -0,0 +1,18 @@
+This is the Ubuntu package of upstart, the event-based init daemon.
+
+Copyright © 2009 Canonical Ltd.
+Copyright © 2009 Scott James Remnant <scott@netsplit.com>
+
+Licence:
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License version 2, as
+published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+On Ubuntu systems, the complete text of the GNU General Public License
+can be found in ‘/usr/share/common-licenses/GPL’.
--- upstart-1.5.orig/debian/manpages/upstart-events.7
+++ upstart-1.5/debian/manpages/upstart-events.7
@@ -0,0 +1,459 @@
+'\" t
+.TH upstart-events 7 2011-03-24 upstart
+.\"
+.SH NAME
+upstart-events \- Well-known Upstart events summary
+.\"
+.SH Event Summary
+
+This manual page summarizes well-known events generated by the Upstart
+.BR init (8)
+daemon.
+It is not an exhaustive list of all possible events, but rather details
+a standard set of events expected to be generated on any Ubuntu system
+running Upstart.
+
+The primary table, \fBTable 1\fP, encodes the well-known events, along
+with the type of each event (listed in \fBTable 2\fP), the emitter of
+the event (see \fBTable 3\fP) and the approximate time at which the
+event could be generated. Additionally, the \fINote\fP column indexes
+into \fBTable 4\fP for further details on a particular event.
+
+The \fIRef\fP (Reference) column is used to refer to individual
+events succinctly in the \fITime\fP column.
+
+Note that the \(aq<\(aq and \(aq>\(aq characters in the \fITime\fP column denote
+that the event in the \fIEvent\fP column occurs respectively before or
+after the event specified in the \fITime\fP column (for example, the
+\fBmounting\fP(7) event occurs "at some time" after the \fBstartup\fP(7)
+event, and the \fBvirtual\-filesystems\fP(7) event occurs after the last
+\fBmounted\fP(7) event relating to a virtual filesystem has been emitted).
+
+For further details on events, consult the manual pages and the job
+configuration files, usually located in \fI/etc/init\fP.
+.\"
+
+.\" Flush-left to allow table to be viewed on 80-col display without
+.\" wrapping.
+.nr old_po .po
+.nr old_in .in
+.po 0
+.in 0
+.sp 1
+\fBTable 1: Well-Known Event Summary.\fP
+.TS
+box, tab (@);
+c | c | c | c | c | c
+c | l | c | c | l | c.
+Ref@Event@Type@Emit@Time@Note
+=
+  @\fBall\-swaps\fP@S@M@> (5)@
+  @\fBcontrol\-alt\-delete\fP(7)@S@A@> (5)@A
+  @container@S@C@> \fI/run\fP mounted@Q
+  @dbus\-activation@S@B@> D\-Bus client request@
+  @deconfiguring\-networking@H@V@< non-local IFs down@P
+  @desktop\-session\-start@H@D@> \fBX\fP(7) session created@B
+  @desktop\-shutdown@H@D@> \fBX\fP(7) session ended@O
+  @device\-not\-ready@H@M@> (2)@N
+  @drm\-device\-added@S@U@> (5)@C
+  @failsafe\-boot@S@X@> (7) and local IF@S
+7@\fBfilesystem\fP@S@M@After last (1)@D
+  @graphics\-device\-added@S@U@> (5)@C
+  @\fBkeyboard\-request\fP(7)@S@A@> (5)@E
+  @\fBlocal\-filesystems\fP(7)@S@M@> (6)@
+  @login\-session\-start@H@D@< DM running@F
+1@\fBmounted\fP(7)@H@M@> associated (2)@G
+2@\fBmounting\fP(7)@H@M@> (5)@H
+3@net\-device\-added@S@U@> (5)@C
+  @net\-device\-changed@S@U@> (5)@C
+  @net\-device\-down@S@F@< (4)@C
+4@net\-device\-removed@S@U@> (5)@C
+  @net\-device\-up@S@F,N@> (3)@C
+  @not\-container@S@C@> \fI/run\fP mounted@Q
+  @\fBpower\-\%status\-\%changed\fP(7)@S@I@> (5)@I
+  @recovery@S@G@Boot (<5)@R
+  @\fBremote\-\%filesystems\fP(7)@S@M@> (6)@
+  @\fBrunlevel\fP(7)@M@T@> (7) + (8)@
+  @\fBsocket\fP(7)@S@S@> socket connection@
+5@\fBstartup\fP(7)@S@I@Boot@J
+  @\fBstarted\fP(7)@S@I@> job started@K
+  @\fBstarting\fP(7)@H@I@< job starts@K
+ 8@static\-network\-up@S@N@> last static IF up@
+  @\fBstopped\fP(7)@S@I@> job stopped@K
+  @\fBstopping\fP(7)@H@I@< job stops@K
+  @T{
+unmounted\-\:remote\-\:filesystems
+T}@H@V@T{
+> last remote FS unmounted
+T}@L
+6@\fBvirtual\-\:filesystems\fP(7)@S@M@> last virtual FS (1)@M
+.TE
+.po \n[old_po]
+.in \n[old_in]
+.P
+Key:
+  \(aqDM\(aq is an abbreviation for Display Manager.
+  \(aqFS\(aq is an abbreviation for filesystem.
+  \(aqIF\(aq is an abbreviation for Network Interface.
+
+.\"
+.P
+.sp 1
+.nr old_po .po
+.nr old_in .in
+.po 0
+.in 0
+\fBTable 2: Event Types.\fP
+.TS
+box, tab (@);
+c | l |l
+c | l |l.
+Ref@Event Type@Notes
+=
+H@Hook@T{
+Blocking. Waits for events that \fBstart on\fP or \fBstop on\fP this
+event.
+T}
+M@Method@Blocking task.
+S@Signal@Non-blocking.
+.TE
+.po \n[old_po]
+.in \n[old_in]
+
+.\"
+.P
+.nr old_po .po
+.nr old_in .in
+.po 0
+.in 0
+.sp 1
+\fBTable 3: Event Emitters.\fP
+.TS
+box, tab (@);
+c | l |l
+c | l |l.
+Ref@Emitter@Notes
+=
+A@System Administrator (initiator)@Technically emitted by init(8).
+B@\fBdbus\-daemon\fP(1)@Run with "\fI\-\-activation=upstart"\fP
+C@container\-detect job@
+D@Display Manager@e.g. lightdm/gdm/kdm/xdm.
+F@\fBifup\fP(8) or \fBifdown\fP(8)@See \fI/etc/network/\fP.
+G@bootloader or initramfs@
+I@\fBinit\fP(8)@
+M@\fBmountall\fP(8)@
+N@network\-interface job@
+S@\fBupstart\-socket\-bridge\fP(8)@
+T@\fBtelinit\fP(8), \fBshutdown\fP(8)@
+U@\fBupstart\-udev\-bridge\fP(8)@
+V@System V init system@
+X@failsafe job@
+.TE
+.po \n[old_po]
+.in \n[old_in]
+
+.\"
+.P
+.nr old_po .po
+.nr old_in .in
+.po 0
+.in 0
+\fBTable 4: Event Summary Notes.\fP
+.TS
+box, tab (@);
+c | l
+c | l.
+Note@Detail
+=
+A@T{
+Requires administrator to press Control-Alt-Delete key
+combination on the console.
+T}
+B@Event generated when user performs graphical login.
+C@T{
+These are specific examples. \fBupstart\-udev\-bridge\fP(8) will emit
+events which match the pattern, "\fIS\fP\-device\-\fIA\fP" where
+\(aqS\(aq is the udev \fIsubsystem\fP and \(aqA\(aq is the udev \fIaction\fP. See
+\fBudev\fP(7) and for further details. If you have sysfs
+mounted, you can look in \fI/sys/class/\fP for possible values for subsystem.
+T}
+D@Note this is in the singular - there is no \(aqfilesystems\(aq event.
+E@T{
+Emitted when administrator presses Alt-UpArrow key combination on
+the console.
+T}
+F@T{
+Denotes Display Manager running (about to be displayed), but no users
+logged in yet.
+T}
+G@Generated for each mount that completes successfully.
+H@T{
+Emitted when mount attempt for single entry from \fBfstab\fP(5)
+for any filesystem type is about to begin.
+T}
+I@Emitted when Upstart receives the SIGPWR signal.
+J@Initial event.
+K@T{
+Although the events are emmitted by \fBinit\fP(8), the instigator may be
+\fBinitctl\fP(8) if a System Administrator has manually started or
+stopped a job.
+T}
+L@\fI/etc/init/umountnfs.sh\fP.
+M@Emitted when all virtual filesystems (such as \fI/proc\fR) mounted.
+N@T{
+Emitted when the \fI\-\-dev\-wait\-time\fP timeout is exceeded for
+\fBmountall\fP(8).  This defaults to 30 seconds.
+T}
+O@T{
+Emitted when the \fIX\fP(7) display manager exits at shutdown or reboot, to
+hand off to the shutdown splash manager.
+T}
+P@T{
+Emitted by /etc/init.d/networking just prior to stopping all non-local
+network interfaces.
+T}
+Q@T{
+Either \(aqcontainer\(aq or \(aqnot-container\(aq is emitted (depending
+on the environment), but not both.
+T}
+R@T{
+Emitted by either the initramfs or bootloader (for example grub) as the \fIinitial\fP
+event (rather than \fBstartup\fP(7)) to denote the system has booted into
+recovery mode. If recovery was successful, the standard \fBstartup\fP(7)
+event is \fIthen\fP emitted, allowing the system to boot as normal.
+T}
+S@T{
+Emitted to indicate the system has failed to boot within the expected
+time. This event will trigger other jobs to forcibly attempt to bring
+the system into a usable state.
+T}
+.TE
+.po \n[old_po]
+.in \n[old_in]
+
+.\" ------------------------------------------------------------
+.SH Job States
+
+.\"
+.P
+.sp 1
+.nr old_po .po
+.nr old_in .in
+.po 0
+.in 0
+\fBTable 5: Job Goals and State Transitions.\fP
+.TS
+box,tab(@);
+c | c s
+c | c s
+c | c | c
+c | l l.
+              @Goal
+              @_
+Current State @start @ stop
+=
+waiting       @ starting    @ n/a
+starting      @ pre\-start  @ stopping
+pre\-start    @ spawned     @ stopping
+spawned       @ post\-start @ stopping
+post\-start   @ running     @ stopping
+running       @ stopping    @ pre\-stop / stopping (*)
+pre\-stop     @ running     @ stopping
+stopping      @ killed      @ killed
+killed        @ post\-stop  @ post\-stop
+post\-stop    @ starting    @ waiting
+.TE
+.po \n[old_po]
+.in \n[old_in]
+.P
+Key:
+  (*) If there is a \fBscript\fP or \fBexec\fP section and this process is running,
+  state will be \(aqpre\-stop\(aq, else it will be \(aqstopping\(aq.
+
+.\" ------------------------------------------------------------
+.SH Job Lifecycle
+.\"
+.\" ------------------------------
+.SS Starting a Job
+
+.nr step 1 1
+.\"
+.IP \n[step] 3
+Initially the job is "at rest" with a goal of \(aqstop\(aq
+and a state of \(aqwaiting\(aq (shown as \(aqstop/waiting\(aq by the
+.BR initctl (8)
+.B list
+and
+.B status
+commands).
+.\"
+.IP \n+[step] 3
+The goal is changed from \(aqstop\(aq to
+\(aqstart\(aq indicating the job is attempting to start.
+.\"
+.IP \n+[step] 3
+The state is changed from \(aqwaiting\(aq to
+\(aqstarting\(aq.
+.\"
+.IP \n+[step] 3
+The \fBstarting\fP(7) event is emitted denoting the job is
+"about to start".
+.\"
+.IP \n+[step] 3
+Any jobs whose \(aqstart on\(aq (or \(aqstop on\(aq) condition would be satisfied
+by this job starting are started (or stopped respectively).
+.\"
+.IP \n+[step] 3
+The \fBstarting\fP(7) event completes.
+.\"
+.IP \n+[step] 3
+The state is changed from \(aqstarting\(aq to \(aqpre\-start\(aq.
+.\"
+.IP \n+[step] 3
+If the \fBpre\-start\fP stanza exists, the pre\-start process is
+spawned.
+.\"
+.IP \n+[step] 3
+If the pre\-start process fails, the goal is changed from
+\(aqstart\(aq to \(aqstop\(aq, and the
+.BR stopping(7)
+and
+.BR stopped(7)
+events are emitted with appropriate variables set denoting the error.
+.\"
+.IP \n+[step] 3
+Assuming the pre\-start did not fail or did not call "stop", the main
+process is spawned.
+.\"
+.IP \n+[step] 3
+The state is changed from \(aqpre\-start\(aq to \(aqspawned\(aq.
+.\"
+.IP \n+[step] 3
+Upstart then ascertains the \fIfinal\fP PID for the job which may be a
+descendent of the immediate child process if \fBexpect fork\fP or
+\fBexpect daemon\fP has been specified.
+.\"
+.IP \n+[step] 3
+The state is changed from \(aqspawned\(aq to \(aqpost\-start\(aq.
+.\"
+.IP \n+[step] 3
+If the \fBpost\-start\fP stanza exists, the post\-start process is
+spawned.
+.\"
+.IP \n+[step] 3
+The state is changed from \(aqpost\-start\(aq to \(aqrunning\(aq.
+.\"
+.IP \n+[step] 3
+The \fBstarted\fP(7) event is emitted.
+.sp 1
+For services, when this event completes the main process will now be fully
+running. If the job refers to a task, it will now have completed
+(successfully or otherwise).
+.\"
+.IP \n+[step] 3
+Any jobs whose \(aqstart on\(aq (or \(aqstop on\(aq) condition would be satisfied
+by this job being started are started (or stopped respectively).
+
+.\" ------------------------------
+.SS Stopping a Job
+
+.nr step 1 1
+.\"
+.IP \n[step] 3
+Assuming the job is fully running, it will have a goal of \(aqstart\(aq
+and a state of \(aqrunning\(aq (shown as \(aqstart/running\(aq by the
+.BR initctl (8)
+.B list
+and
+.B status
+commands).
+.\"
+.IP \n+[step] 3
+The goal is changed from \(aqstart\(aq to \(aqstop\(aq indicating the
+job is attempting to stop.
+.\"
+.IP \n+[step] 3
+The state is changed from \(aqrunning\(aq to
+\(aqpre\-stop\(aq.
+.\"
+.IP \n+[step] 3
+If the \fBpre\-stop\fP stanza exists, the pre\-stop process is
+spawned.
+.\"
+.IP \n+[step] 3
+The state is changed from \(aqpre\-stop\(aq to \(aqstopping\(aq.
+.\"
+.IP \n+[step] 3
+The \fBstopping\fP(7) event is emitted.
+.\"
+.IP \n+[step] 3
+Any jobs whose \(aqstart on\(aq (or \(aqstop on\(aq) condition would be satisfied by this
+job stopping are started (or stopped respectively).
+.\"
+.IP \n+[step] 3
+The main process is stopped:
+.RS
+.nr step2 1 1
+.af step2 i
+.IP \n[step2] 3
+The signal specified by the
+.B kill signal
+stanza is sent to the process group of the main process
+(such that all processes belonging to the jobs main process are killed).
+By default this signal is
+.BR SIGTERM "."
+.sp 1
+See \fBsignal\fP(7) and \fBinit\fP(5).
+.IP \n+[step2] 3
+Upstart waits for up to "kill timeout" seconds (default 5 seconds) for
+the process to end.
+.IP \n+[step2] 3
+If the process is still running after the timeout, a
+.B SIGKILL
+signal is sent to the process which cannot be ignored and will forcibly
+stop the processes in the process group.
+.RE
+.\"
+.IP \n+[step] 3
+The state is changed from \(aqkilled\(aq to \(aqpost\-stop\(aq.
+.\"
+.IP \n+[step] 3
+If the \fBpost\-stop\fP stanza exists, the post\-stop process is
+spawned.
+.\"
+.IP \n+[step] 3
+The state is changed from \(aqpost\-stop\(aq to \(aqwaiting\(aq.
+.\"
+.IP \n+[step] 3
+The \fBstopped\fP(7) event is emitted.
+.sp 1
+When this event completes, the job is fully stopped.
+.\"
+.IP \n+[step] 3
+Any jobs whose \(aqstart on\(aq (or \(aqstop on\(aq) condition would be satisfied
+by this job being stopped are started (or stopped respectively).
+
+.SH AUTHOR
+Manual page written by James Hunt
+.RB < james.hunt@ubuntu.com >
+.\"
+.SH REPORTING BUGS
+Report bugs at
+.RB < https://launchpad.net/ubuntu/+source/upstart/+bugs >
+.\"
+.SH COPYRIGHT
+Copyright \(co 2011-2012 Canonical Ltd.
+.br
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+.\"
+.SH SEE ALSO
+.BR init (5)
+.BR init (8)
+.BR initctl (8)
+.BR mountall (8)
+.BR started (7)
+.BR starting (7)
+.BR stopped (7)
+.BR stopping (7)
+.BR telinit (8)
--- upstart-1.5.orig/debian/migrate-inittab.pl
+++ upstart-1.5/debian/migrate-inittab.pl
@@ -0,0 +1,143 @@
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+
+my %gettys;
+my $have_cad = 0;
+
+
+#-----------------------------------------------------------------------------#
+# Parse /etc/inittab
+#-----------------------------------------------------------------------------#
+
+open INITTAB, "/etc/inittab"
+    or die "Unable to open /etc/inittab: $!";
+
+while (<INITTAB>) {
+    chomp;
+    s/^\s*//;
+
+    next if /^\#/;
+    next unless length;
+
+    my ($id, $rlevel, $action, $process) = split /:/, $_, 4;
+
+    warn "missing id field" and next
+	unless defined $id and length $id;
+    warn "missing runlevel field" and next
+	unless defined $rlevel;
+    warn "missing action field" and next
+	unless defined $action and length $action;
+    warn "missing process field" and next
+	unless defined $process;
+
+
+    $have_cad = 1 if $action eq "ctrlaltdel";
+    $gettys{$1} = [ $rlevel, $process ]	if $process =~ /getty.*\b(tty\w+)/;
+}
+
+close INITTAB
+    or warn "Error while closing /etc/inittab: $!";
+
+
+#-----------------------------------------------------------------------------#
+# Alter /etc/event.d
+#-----------------------------------------------------------------------------#
+
+unlink "/etc/init/control-alt-delete.conf"
+    unless $have_cad;
+
+foreach (qw/tty1 tty2 tty3 tty4 tty5 tty6/) {
+    unlink "/etc/init/$_.conf"
+	unless exists $gettys{$_};
+}
+
+foreach (sort keys %gettys) {
+    my ($rlevel, $process) = @{$gettys{$_}};
+
+    my @job;
+    if (-f "/etc/event.d/$_") {
+	open JOB, "/etc/event.d/$_"
+	    or warn "Unable to open /etc/event.d/$_: $!" and next;
+	@job = <JOB>;
+	chomp @job;
+	close JOB
+	    or warn "Error while closing /etc/event,d/$_: $!" and next;
+
+	foreach my $rl (qw/2 3 4 5/) {
+	    my $idx;
+	    for ($idx = 0; $idx < @job; $idx++) {
+		last if $job[$idx] =~ /^\s*(start|stop)\s+on\s+runlevel\s+$rl\b/;
+	    }
+
+	    if ($idx < @job) {
+		if ($rlevel =~ /$rl/) {
+		    $job[$idx] =~ s/^(\s*)stop(\s+)/$1start$2/;
+		} else {
+		    $job[$idx] =~ s/^(\s*)start(\s+)/$1stop$2/;
+		}
+	    } else {
+		if ($rlevel =~ /$rl/) {
+		    push @job, "start on runlevel $rl";
+		} else {
+		    push @job, "stop on runlevel $rl";
+		}
+	    }
+	}
+
+	my $idx;
+	for ($idx = 0; $idx < @job; $idx++) {
+	    last if $job[$idx] =~ /^\s*respawn\s*/; # match bare 'respawn' too
+	}
+
+	if ($idx < @job) {
+	    # only match old-style 'respawn process', not bare 'respawn'
+	    $job[$idx] =~ s/^(\s*respawn\s+).*/$1$process/;
+	} else {
+	    push @job, "respawn";
+	    push @job, "exec $process";
+	}
+
+	# Try to fix up effects of previous broken migrations
+	if (@job and $job[$#job] =~ /.*(.+?)exec (\1)$/) {
+	    $job[$#job] = "exec $1";
+	}
+
+    } else {
+	push @job, "# $_ - getty";
+	push @job, "#";
+	push @job, "# Converted from /etc/inittab entry";
+	push @job, "";
+
+	foreach my $rl (qw/2 3 4 5/) {
+	    if ($rlevel =~ /$rl/) {
+		push @job, "start on runlevel $rl";
+	    } else {
+		push @job, "stop on runlevel $rl";
+	    }
+	}
+	push @job, "";
+
+	push @job, "stop on shutdown";
+	push @job, "";
+
+	push @job, "respawn";
+	push @job, "exec $process";
+    }
+
+    open JOB, ">/etc/event.d/.$_"
+	or warn "Unable to write to /etc/event.d/.$_: $!" and next;
+    print JOB map { "$_\n" } @job;
+    unless (close JOB) {
+	warn "Error while closing /etc/event.d/.$_: $!";
+	unlink "/etc/event.d/.$_";
+	next;
+    }
+
+    unless (rename "/etc/event.d/.$_", "/etc/event.d/$_") {
+	warn "Unable to replace /etc/event.d/$_: $!";
+	unlink "/etc/event.d/.$_";
+	next;
+    }
+}
--- upstart-1.5.orig/debian/rules
+++ upstart-1.5/debian/rules
@@ -0,0 +1,27 @@
+#!/usr/bin/make -f
+
+DEB_BUILD_MAINT_OPTIONS  := hardening=+pie,+bindnow
+DEB_LDFLAGS_MAINT_APPEND := -Wl,--as-needed
+DEB_CFLAGS_MAINT_APPEND  := -Wall
+
+# Disable optimisations if noopt found in $DEB_BUILD_OPTIONS
+ifneq (,$(findstring noopt,$(DEB_BUILD_OPTIONS)))
+	DEB_LDFLAGS_MAINT_APPEND += -Wl,-O0
+else
+	DEB_CFLAGS_MAINT_APPEND += -Os
+	DEB_LDFLAGS_MAINT_APPEND += -Wl,-O1
+endif
+
+export DEB_BUILD_MAINT_OPTIONS DEB_LDFLAGS_MAINT_APPEND DEB_CFLAGS_MAINT_APPEND
+
+%:
+	dh $@ --with bash-completion
+
+override_dh_auto_configure:
+	dh_auto_configure -- --exec-prefix=
+
+override_dh_fixperms:
+	dh_fixperms
+	chmod 755 debian/upstart/lib/init/upstart-job
+	chmod 755 debian/upstart/lib/init/apparmor-profile-load
+	chmod 755 debian/upstart/usr/lib/upstart/migrate-inittab.pl
--- upstart-1.5.orig/debian/running-in-container
+++ upstart-1.5/debian/running-in-container
@@ -0,0 +1,10 @@
+#!/bin/sh
+# Return 0 if in a container, 1 if not
+# if in a container, also print the container type
+status container-detect 2>/dev/null | grep -q start
+
+if [ $? -eq 0 ]; then
+    [ -f /run/container_type ] && cat /run/container_type
+    exit 0
+fi
+exit 1
--- upstart-1.5.orig/debian/source/format
+++ upstart-1.5/debian/source/format
@@ -0,0 +1 @@
+1.0
--- upstart-1.5.orig/debian/upstart-job
+++ upstart-1.5/debian/upstart-job
@@ -0,0 +1,115 @@
+#!/bin/sh -e
+# upstart-job
+#
+# Symlink target for initscripts that have been converted to Upstart.
+
+set -e
+
+INITSCRIPT="$(basename "$0")"
+JOB="${INITSCRIPT%.sh}"
+
+if [ "$JOB" = "upstart-job" ]; then
+    if [ -z "$1" ]; then
+        echo "Usage: upstart-job JOB COMMAND" 1>&2
+	exit 1
+    fi
+
+    JOB="$1"
+    INITSCRIPT="$1"
+    shift
+else
+    if [ -z "$1" ]; then
+        echo "Usage: $0 COMMAND" 1>&2
+	exit 1
+    fi
+fi
+
+COMMAND="$1"
+shift
+
+
+if [ -z "$DPKG_MAINTSCRIPT_PACKAGE" ]; then
+	ECHO=echo
+else
+	ECHO=:
+fi
+
+$ECHO "Rather than invoking init scripts through /etc/init.d, use the service(8)"
+$ECHO "utility, e.g. service $INITSCRIPT $COMMAND"
+
+# Only check if jobs are disabled if the currently _running_ version of
+# Upstart (which may be older than the latest _installed_ version)
+# supports such a query.
+#
+# This check is necessary to handle the scenario when upgrading from a
+# release without the 'show-config' command (introduced in
+# Upstart for Ubuntu version 0.9.7) since without this check, all
+# installed packages with associated Upstart jobs would be considered
+# disabled.
+#
+# Once Upstart can maintain state on re-exec, this change can be
+# dropped (since the currently running version of Upstart will always
+# match the latest installed version).
+
+UPSTART_VERSION_RUNNING=$(initctl version|awk '{print $3}'|tr -d ')')
+
+if dpkg --compare-versions "$UPSTART_VERSION_RUNNING" ge 0.9.7
+then
+    initctl show-config -e "$JOB"|grep -q '^  start on' || DISABLED=1
+fi
+
+case $COMMAND in
+status)
+    $ECHO
+    $ECHO "Since the script you are attempting to invoke has been converted to an"
+    $ECHO "Upstart job, you may also use the $COMMAND(8) utility, e.g. $COMMAND $JOB"
+    $COMMAND "$JOB"
+    ;;
+start|stop)
+    $ECHO
+    $ECHO "Since the script you are attempting to invoke has been converted to an"
+    $ECHO "Upstart job, you may also use the $COMMAND(8) utility, e.g. $COMMAND $JOB"
+    if status "$JOB" 2>/dev/null | grep -q ' start/'; then
+        RUNNING=1
+    fi
+    if [ -z "$RUNNING" ] && [ "$COMMAND" = "stop" ]; then
+        exit 0
+    elif [ -n "$RUNNING" ] && [ "$COMMAND" = "start" ]; then
+        exit 0
+    elif [ -n "$DISABLED" ] && [ "$COMMAND" = "start" ]; then
+        exit 0
+    fi
+    $COMMAND "$JOB"
+    ;;
+restart)
+    $ECHO
+    $ECHO "Since the script you are attempting to invoke has been converted to an"
+    $ECHO "Upstart job, you may also use the stop(8) and then start(8) utilities,"
+    $ECHO "e.g. stop $JOB ; start $JOB. The restart(8) utility is also available."
+    if status "$JOB" 2>/dev/null | grep -q ' start/'; then
+        RUNNING=1
+    fi
+    if [ -n "$RUNNING" ] ; then
+        stop "$JOB"
+    fi
+    # If the job is disabled and is not currently running, the job is
+    # not restarted. However, if the job is disabled but has been forced into the
+    # running state, we *do* stop and restart it since this is expected behaviour
+    # for the admin who forced the start.
+    if [ -n "$DISABLED" ] && [ -z "$RUNNING" ]; then
+        exit 0
+    fi
+    start "$JOB"
+    ;;
+reload|force-reload)
+    $ECHO
+    $ECHO "Since the script you are attempting to invoke has been converted to an"
+    $ECHO "Upstart job, you may also use the reload(8) utility, e.g. reload $JOB"
+    reload "$JOB"
+    ;;
+*)
+    $ECHO
+    $ECHO "The script you are attempting to invoke has been converted to an Upstart" 1>&2
+    $ECHO "job, but $COMMAND is not supported for Upstart jobs." 1>&2
+    exit 1
+esac
--- upstart-1.5.orig/debian/upstart.bash-completion
+++ upstart-1.5/debian/upstart.bash-completion
@@ -0,0 +1 @@
+contrib/bash_completion/upstart
--- upstart-1.5.orig/debian/upstart.dirs
+++ upstart-1.5/debian/upstart.dirs
@@ -0,0 +1 @@
+/var/log/upstart
--- upstart-1.5.orig/debian/upstart.docs
+++ upstart-1.5/debian/upstart.docs
@@ -0,0 +1,2 @@
+AUTHORS
+NEWS
--- upstart-1.5.orig/debian/upstart.install
+++ upstart-1.5/debian/upstart.install
@@ -0,0 +1,5 @@
+debian/conf/*.conf etc/init/
+debian/upstart-job lib/init/
+debian/apparmor-profile-load lib/init/
+debian/migrate-inittab.pl usr/lib/upstart/
+debian/running-in-container bin/
--- upstart-1.5.orig/debian/upstart.logrotate
+++ upstart-1.5/debian/upstart.logrotate
@@ -0,0 +1,8 @@
+/var/log/upstart/*.log {
+        daily
+        missingok
+        rotate 7
+        compress
+        notifempty
+	nocreate
+}
--- upstart-1.5.orig/debian/upstart.manpages
+++ upstart-1.5/debian/upstart.manpages
@@ -0,0 +1 @@
+debian/manpages/*
--- upstart-1.5.orig/debian/upstart.postinst
+++ upstart-1.5/debian/upstart.postinst
@@ -0,0 +1,62 @@
+#!/bin/sh -e
+# This script can be called in the following ways:
+#
+# After the package was installed:
+#	<postinst> configure <old-version>
+#
+#
+# If prerm fails during upgrade or fails on failed upgrade:
+#	<old-postinst> abort-upgrade <new-version>
+#
+# If prerm fails during deconfiguration of a package:
+#	<postinst> abort-deconfigure in-favour <new-package> <version>
+#	           removing <old-package> <version>
+#
+# If prerm fails during replacement due to conflict:
+#	<postinst> abort-remove in-favour <new-package> <version>
+
+
+# Remove a no-longer used conffile
+rm_conffile()
+{
+    CONFFILE="$1"
+
+    if [ -e "$CONFFILE".dpkg-obsolete ]; then
+	echo "Removing obsolete conffile $CONFFILE"
+	rm -f "$CONFFILE".dpkg-obsolete
+    fi
+}
+
+
+case "$1" in
+    configure)
+        if dpkg --compare-versions "$2" lt-nl 0.6.0; then
+	    # We're upgrading from a version of Upstart that doesn't use
+	    # D-Bus for its IPC.  We have to tell it to re-exec into one
+	    # that does.  It'll lose all state, but we didn't keep much
+	    # in those days.
+	    telinit u
+	else
+	    # Before we shutdown or reboot, we need to re-exec so that we
+	    # can safely remount the root filesystem; we can't just do that
+	    # here because we lose state.
+	    touch /var/run/init.upgraded || :
+	fi
+
+	# Upgrade from karmic development version
+	if dpkg --compare-versions "$2" lt-nl 0.6.3-7; then
+	    rm_conffile /etc/init/dbus-reconnect.conf
+	fi
+	;;
+
+    abort-upgrade|abort-deconfigure|abort-remove)
+	;;
+
+    *)
+	echo "$0 called with unknown argument \`$1'" 1>&2
+	exit 1
+	;;
+esac
+
+#DEBHELPER#
+exit 0
--- upstart-1.5.orig/debian/upstart.postrm
+++ upstart-1.5/debian/upstart.postrm
@@ -0,0 +1,81 @@
+#!/bin/sh -e
+# This script can be called in the following ways:
+#
+# After the package was removed:
+#	<postrm> remove
+#
+# After the package was purged:
+#	<postrm> purge
+#
+# After the package was upgraded:
+#	<old-postrm> upgrade <new-version>
+# if that fails:
+#	<new-postrm> failed-upgrade <old-version>
+#
+#
+# After all of the packages files have been replaced:
+#	<postrm> disappear <overwriting-package> <version>
+#
+#
+# If preinst fails during install:
+#	<new-postrm> abort-install
+#
+# If preinst fails during upgrade of removed package:
+#	<new-postrm> abort-install <old-version>
+#
+# If preinst fails during upgrade:
+#	<new-postrm> abort-upgrade <old-version>
+
+
+# Undo removal of a no-longer used conffile
+undo_rm_conffile()
+{
+    CONFFILE="$1"
+
+    if [ ! -e "$CONFFILE" ]; then
+	if [ -e "$CONFFILE".dpkg-bak ]; then
+	    echo "Restoring modified conffile $CONFFILE"
+	    mv -f "$CONFFILE".dpkg-bak "$CONFFILE"
+	elif [ -e "$CONFFILE".dpkg-obsolete ]; then
+	    mv -f "$CONFFILE".dpkg-obsolete "$CONFFILE"
+	fi
+    fi
+}
+
+# Finish removal of a no-longer used conffile
+finish_rm_conffile()
+{
+    CONFFILE="$1"
+
+    if [ -e "$CONFFILE".dpkg-bak ]; then
+	rm -f "$CONFFILE".dpkg-bak
+    fi
+}
+
+
+case "$1" in
+    remove)
+	;;
+
+    purge)
+    	finish_rm_conffile /etc/init/dbus-reconnect.conf
+	;;
+
+    upgrade|failed-upgrade|disappear)
+	;;
+
+    abort-install|abort-upgrade)
+	# Abort upgrade from karmic development version
+	if dpkg --compare-versions "$2" lt-nl 0.6.3-7; then
+	    undo_rm_conffile /etc/init/dbus-reconnect.conf
+	fi
+	;;
+
+    *)
+	echo "$0 called with unknown argument \`$1'" 1>&2
+	exit 1
+	;;
+esac
+
+#DEBHELPER#
+exit 0
--- upstart-1.5.orig/debian/upstart.preinst
+++ upstart-1.5/debian/upstart.preinst
@@ -0,0 +1,54 @@
+#!/bin/sh -e
+# This script can be called in the following ways:
+#
+# Before the package is installed:
+#	<new-preinst> install
+#
+# Before removed package is upgraded:
+#	<new-preinst> install <old-version>
+#
+# Before the package is upgraded:
+#	<new-preinst> upgrade <old-version>
+#
+#
+# If postrm fails during upgrade or fails on failed upgrade:
+#	<old-preinst> abort-upgrade <new-version>
+
+
+# Prepare to remove a no-longer used conffile
+prep_rm_conffile()
+{
+    CONFFILE="$1"
+
+    if [ -e "$CONFFILE" ]; then
+        md5sum="`md5sum \"$CONFFILE\" | sed -e \"s/ .*//\"`"
+        old_md5sum="`sed -n -e \"/^Conffiles:/,/^[^ ]/{\\\\' $CONFFILE '{s/ obsolete$//;s/.* //;p}}\" /var/lib/dpkg/status`"
+        if [ "$md5sum" != "$old_md5sum" ]; then
+            echo "Obsolete conffile $CONFFILE has been modified by you, renaming to .dpkg-bak"
+            mv -f "$CONFFILE" "$CONFFILE".dpkg-bak
+	else
+	    mv -f "$CONFFILE" "$CONFFILE".dpkg-obsolete
+	fi
+    fi
+}
+
+
+case "$1" in
+    install|upgrade)
+	# Upgrade from karmic development version
+	if dpkg --compare-versions "$2" lt-nl 0.6.3-7; then
+	    prep_rm_conffile /etc/init/dbus-reconnect.conf
+	fi
+	;;
+
+    abort-upgrade)
+	;;
+
+    *)
+	echo "$0 called with unknown argument \`$1'" 1>&2
+	exit 1
+	;;
+esac
+
+#DEBHELPER#
+exit 0
--- upstart-1.5.orig/extra/conf/upstart-udev-bridge.conf
+++ upstart-1.5/extra/conf/upstart-udev-bridge.conf
@@ -5,7 +5,13 @@
 
 description	"Bridge udev events into upstart"
 
-emits *-device-*
+# From upstart-udev-bridge itself
+emits *-device-added
+emits *-device-removed
+emits *-device-changed
+# From http://www.kernel.org/pub/linux/utils/kernel/hotplug/libudev/libudev-udev-device.html
+emits *-device-online
+emits *-device-offline
 
 start on starting udev
 stop on stopped udev
--- upstart-1.5.orig/init/conf.c
+++ upstart-1.5/init/conf.c
@@ -840,9 +840,14 @@
 		nih_debug ("Reloading configuration for %s on deletion of overide (%s)",
 				new_path, path);
 
-		if ( conf_reload_path (source, new_path, NULL) < 0 ) {
-			nih_warn ("%s: %s", new_path,
-					_("Unable to reload configuration after override deletion"));
+		if (conf_reload_path (source, new_path, NULL) < 0) {
+			NihError *err;
+
+			err = nih_error_get ();
+			nih_warn ("%s: %s: %s", new_path,
+					_("Unable to reload configuration after override deletion"),
+					err->message);
+			nih_free (err);
 		}
 	}
 }
--- upstart-1.5.orig/init/main.c
+++ upstart-1.5/init/main.c
@@ -28,9 +28,11 @@
 #include <sys/ioctl.h>
 #include <sys/reboot.h>
 #include <sys/resource.h>
+#include <sys/mount.h>
 
 #include <errno.h>
 #include <stdio.h>
+#include <dirent.h>
 #include <limits.h>
 #include <signal.h>
 #include <stdlib.h>
@@ -65,6 +67,9 @@
 #ifndef DEBUG
 static int  logger_kmsg     (NihLogLevel priority, const char *message);
 static void crash_handler   (int signum);
+#endif /* DEBUG */
+static void term_handler    (void *data, NihSignal *signal);
+#ifndef DEBUG
 static void cad_handler     (void *data, NihSignal *signal);
 static void kbd_handler     (void *data, NihSignal *signal);
 static void pwr_handler     (void *data, NihSignal *signal);
@@ -192,6 +197,8 @@
 #ifndef DEBUG
 	if (use_session_bus == FALSE) {
 
+		int needs_devtmpfs = 0;
+
 		/* Check we're root */
 		if (getuid ()) {
 			nih_fatal (_("Need to be root"));
@@ -236,26 +243,68 @@
 		 */
 		setsid ();
 
+		/* Allow devices to be created with the actual perms
+		 * specified.
+		 */
+		(void)umask (0);
+
+		/* Check if key /dev entries already exist; if they do,
+		 * we should assume we don't need to mount /dev.
+		 */
+		if (system_check_file ("/dev/ptmx", S_IFCHR, makedev (5, 2)) < 0
+			|| system_check_file ("/dev/pts", S_IFDIR, 0) < 0)
+			needs_devtmpfs = 1;
+
+		if (needs_devtmpfs) {
+			if (system_mount ("devtmpfs", "/dev", (MS_NOEXEC | MS_NOSUID)) < 0) {
+				NihError *err;
+
+				err = nih_error_get ();
+				nih_error ("%s: %s", _("Unable to mount /dev filesystem"),
+						err->message);
+				nih_free (err);
+			}
+
+			/* Required to exist before /dev/pts accessed */
+			system_mknod ("/dev/ptmx", (S_IFCHR | 0666), makedev (5, 2));
+
+			if (mkdir ("/dev/pts", 0755) < 0 && errno != EEXIST)
+				nih_error ("%s: %s", _("Cannot create directory"), "/dev/pts");
+		}
+
+		if (system_mount ("devpts", "/dev/pts", (MS_NOEXEC | MS_NOSUID)) < 0) {
+			NihError *err;
+
+			err = nih_error_get ();
+			nih_error ("%s: %s", _("Unable to mount /dev/pts filesystem"),
+					err->message);
+			nih_free (err);
+		}
+
+		/* These devices must exist, but we have to have handled the /dev
+		 * check (and possible mount) prior to considering
+		 * creating them. And yet, if /dev is not available from
+		 * the outset and an error occurs, we are unable to report it,
+		 * hence these checks are performed as early as is
+		 * feasible.
+		 */
+		system_mknod ("/dev/null", (S_IFCHR | 0666), makedev (1, 3));
+		system_mknod ("/dev/tty", (S_IFCHR | 0666), makedev (5, 0));
+		system_mknod ("/dev/console", (S_IFCHR | 0600), makedev (5, 1));
+		system_mknod ("/dev/kmsg", (S_IFCHR | 0600), makedev (1, 11));
+
 		/* Set the standard file descriptors to the ordinary console device,
 		 * resetting it to sane defaults unless we're inheriting from another
 		 * init process which we know left it in a sane state.
 		 */
-		if (system_setup_console (CONSOLE_OUTPUT, (! restart)) < 0) {
+		if (system_setup_console (CONSOLE_NONE, (! restart)) < 0) {
 			NihError *err;
-	
 			err = nih_error_get ();
-			nih_warn ("%s: %s", _("Unable to initialize console, will try /dev/null"),
-				  err->message);
+			nih_fatal ("%s: %s", _("Unable to initialize console as /dev/null"),
+				   err->message);
 			nih_free (err);
 	
-			if (system_setup_console (CONSOLE_NONE, FALSE) < 0) {
-				err = nih_error_get ();
-				nih_fatal ("%s: %s", _("Unable to initialize console as /dev/null"),
-					   err->message);
-				nih_free (err);
-	
-				exit (1);
-			}
+			exit (1);
 		}
 
 		/* Set the PATH environment variable */
@@ -271,9 +320,10 @@
 
 		/* Mount the /proc and /sys filesystems, which are pretty much
 		 * essential for any Linux system; not to mention used by
-		 * ourselves.
+		 * ourselves. Also mount /dev/pts to allow CONSOLE_LOG
+		 * to function if booted in an initramfs-less environment.
 		 */
-		if (system_mount ("proc", "/proc") < 0) {
+		if (system_mount ("proc", "/proc", (MS_NODEV | MS_NOEXEC | MS_NOSUID)) < 0) {
 			NihError *err;
 
 			err = nih_error_get ();
@@ -282,7 +332,7 @@
 			nih_free (err);
 		}
 
-		if (system_mount ("sysfs", "/sys") < 0) {
+		if (system_mount ("sysfs", "/sys", (MS_NODEV | MS_NOEXEC | MS_NOSUID)) < 0) {
 			NihError *err;
 
 			err = nih_error_get ();
@@ -356,6 +406,13 @@
 		/* SIGUSR1 instructs us to reconnect to D-Bus */
 		nih_signal_set_handler (SIGUSR1, nih_signal_handler);
 		NIH_MUST (nih_signal_add_handler (NULL, SIGUSR1, usr1_handler, NULL));
+
+		/* SIGTERM instructs us to re-exec ourselves; this should be the
+		 * last in the list to ensure that all other signals are handled
+		 * before a SIGTERM.
+		 */
+		nih_signal_set_handler (SIGTERM, nih_signal_handler);
+		NIH_MUST (nih_signal_add_handler (NULL, SIGTERM, term_handler, NULL));
 	}
 #endif /* DEBUG */
 
@@ -463,6 +520,16 @@
 	 * init daemon that exec'd us
 	 */
 	if (! restart) {
+		DIR                *piddir;
+
+		/* Look in well-known locations for pid files.
+		 *
+		 * Try /run (the newer) location first, but fall back to
+		 * the original location for older systems.
+		 */
+		const char * const  pid_paths[] = { "/run/initramfs/", "/dev/.initramfs/", NULL };
+		const char * const *pid_path;
+
 		if (disable_startup_event) {
 			nih_debug ("Startup event disabled");
 		} else {
@@ -471,6 +538,68 @@
 				? initial_event
 				: STARTUP_EVENT,
 				NULL));
+                }
+
+		for (pid_path = pid_paths; pid_path && *pid_path; pid_path++) {
+			struct dirent *ent;
+
+			/* Total hack, look for .pid files in known
+			 * locations - if there's a job config for them pretend
+			 * that we started it and it has that pid.
+			 */
+			piddir = opendir (*pid_path);
+			if (! piddir)
+				continue;
+
+			while ((ent = readdir (piddir)) != NULL) {
+				char      path[PATH_MAX];
+				char *    ptr;
+				FILE *    pidfile;
+				pid_t     pid;
+				JobClass *class;
+				Job *     job;
+
+				if (ent->d_name[0] == '.')
+					continue;
+
+				strcpy (path, *pid_path);
+				strcat (path, ent->d_name);
+
+				ptr = strrchr (ent->d_name, '.');
+				if ((! ptr) || strcmp (ptr, ".pid"))
+					continue;
+
+				*ptr = '\0';
+				pidfile = fopen (path, "r");
+				if (! pidfile)
+					continue;
+
+				pid = -1;
+				if (fscanf (pidfile, "%d", &pid))
+					;
+				fclose (pidfile);
+
+				if ((pid < 0) || (kill (pid, 0) < 0))
+					continue;
+
+				class = (JobClass *)nih_hash_lookup (job_classes, ent->d_name);
+				if (! class)
+					continue;
+				if (! class->process[PROCESS_MAIN])
+					continue;
+				if (strlen (class->instance))
+					continue;
+
+				job = NIH_MUST (job_new (class, ""));
+				job->goal = JOB_START;
+				job->state = JOB_RUNNING;
+				job->pid[PROCESS_MAIN] = pid;
+
+				nih_debug ("%s inherited from initramfs with pid %d", class->name, pid);
+			}
+
+			closedir (piddir);
+			break;
 		}
 
 	} else {
@@ -630,8 +759,61 @@
 	/* Goodbye, cruel world. */
 	exit (signum);
 }
+#endif
 
 /**
+ * term_handler:
+ * @data: unused,
+ * @signal: signal caught.
+ *
+ * This is called when we receive the TERM signal, which instructs us
+ * to reexec ourselves.
+ **/
+static void
+term_handler (void      *data,
+	      NihSignal *signal)
+{
+	NihError   *err;
+	const char *loglevel;
+	sigset_t    mask, oldmask;
+
+	nih_assert (argv0 != NULL);
+	nih_assert (signal != NULL);
+
+	nih_warn (_("Re-executing %s"), argv0);
+
+	/* Block signals while we work.  We're the last signal handler
+	 * installed so this should mean that they're all handled now.
+	 *
+	 * The child must make sure that it unblocks these again when
+	 * it's ready.
+	 */
+	sigfillset (&mask);
+	sigprocmask (SIG_BLOCK, &mask, &oldmask);
+
+	/* Argument list */
+	if (nih_log_priority <= NIH_LOG_DEBUG) {
+		loglevel = "--debug";
+	} else if (nih_log_priority <= NIH_LOG_INFO) {
+		loglevel = "--verbose";
+	} else if (nih_log_priority >= NIH_LOG_ERROR) {
+		loglevel = "--error";
+	} else {
+		loglevel = NULL;
+	}
+	execl (argv0, argv0, "--restart", loglevel, NULL);
+	nih_error_raise_system ();
+
+	err = nih_error_get ();
+	nih_error (_("Failed to re-execute %s: %s"), argv0, err->message);
+	nih_free (err);
+
+	sigprocmask (SIG_SETMASK, &oldmask, NULL);
+}
+
+
+#ifndef DEBUG
+/**
  * cad_handler:
  * @data: unused,
  * @signal: signal that called this handler.
--- upstart-1.5.orig/init/man/init.5
+++ upstart-1.5/init/man/init.5
@@ -991,4 +991,5 @@
 .BR init (8)
 .BR initctl (8)
 .BR sh (1)
+.BR upstart-events (7)
 .BR pty (7)
--- upstart-1.5.orig/init/man/init.8
+++ upstart-1.5/init/man/init.8
@@ -48,6 +48,10 @@
 and
 .BR stopped (7)
 events emitted as jobs change state.
+
+See
+.BR upstart-events (7)
+for a summary of well-known events.
 .\"
 .SS System V compatibility
 The Upstart
@@ -157,3 +161,4 @@
 .BR stopping (7)
 .BR stopped (7)
 .BR telinit (8)
+.BR upstart-events (7)
--- upstart-1.5.orig/init/system.c
+++ upstart-1.5/init/system.c
@@ -164,9 +164,10 @@
 /**
  * system_mount:
  * @type: filesystem type,
- * @dir: mountpoint.
+ * @dir: mountpoint,
+ * @flags: mount flags.
  *
- * Mount the kernel filesystem @type at @dir, if not already mounted.  This
+ * Mount the kernel filesystem @type at @dir with @flags, if not already mounted.  This
  * is used to ensure that the proc and sysfs filesystems are always
  * available.
  *
@@ -177,7 +178,8 @@
  **/
 int
 system_mount (const char *type,
-	      const char *dir)
+	      const char *dir,
+	      unsigned long flags)
 {
 	nih_local char *parent = NULL;
 	char *          ptr;
@@ -206,9 +208,65 @@
 		return 0;
 
 	/* Mount the filesystem */
-	if (mount ("none", dir, type,
-		   MS_NODEV | MS_NOEXEC | MS_NOSUID, NULL) < 0)
+	if (mount ("none", dir, type, flags, NULL) < 0)
 		nih_return_system_error (-1);
 
 	return 0;
 }
+
+/**
+ * system_mknod:
+ *
+ * @path: full path,
+ * @mode: mode to create device with,
+ * @dev: device major and minor numbers.
+ *
+ * Create specified device.
+ *
+ * Note that depending on the device, if an error occurs
+ * it may not be reportable, hence no return value,
+ * but an attempt to display an error.
+ **/
+void
+system_mknod (const char *path, mode_t mode, dev_t dev)
+{
+	nih_assert (path);
+
+	if (mknod (path, mode, dev) < 0 && errno != EEXIST)
+		nih_error ("%s: %s", _("Unable to create device"), path);
+}
+
+/**
+ * system_check_file:
+ *
+ * @path: full path,
+ * @type: file type,
+ * @dev: device major and minor numbers (only checked for character and
+ * block devices).
+ *
+ * Perform checks on specified file.
+ *
+ * Returns: 0 if device exists and has the specified @path,
+ * @type and @dev attributes, else -1.
+ **/
+int
+system_check_file (const char *path, mode_t type, dev_t dev)
+{
+	struct stat  statbuf;
+	int          ret;
+
+	nih_assert (path);
+
+	ret = stat (path, &statbuf);
+
+	if (ret < 0 || ! ((statbuf.st_mode & S_IFMT) == type))
+		return -1;
+
+	if (type == S_IFCHR || type == S_IFBLK) {
+		if (major (statbuf.st_rdev) != major (dev)
+			|| minor (statbuf.st_rdev) != minor (dev))
+		return -1;
+	}
+
+	return 0;
+}
--- upstart-1.5.orig/init/system.h
+++ upstart-1.5/init/system.h
@@ -35,7 +35,13 @@
 int system_setup_console (ConsoleType type, int reset)
 	__attribute__ ((warn_unused_result));
 
-int system_mount         (const char *type, const char *dir)
+int system_mount         (const char *type, const char *dir,
+			  unsigned long flags)
+	__attribute__ ((warn_unused_result));
+
+void system_mknod        (const char *path, mode_t mode, dev_t dev);
+
+int  system_check_file   (const char *path, mode_t type, dev_t dev)
 	__attribute__ ((warn_unused_result));
 
 NIH_END_EXTERN
--- upstart-1.5.orig/init/tests/test_job_process.c
+++ upstart-1.5/init/tests/test_job_process.c
@@ -2,7 +2,7 @@
  *
  * test_job_process.c - test suite for init/job_process.c
  *
- * Copyright © 2011 Canonical Ltd.
+ * Copyright  2011 Canonical Ltd.
  * Author: Scott James Remnant <scott@netsplit.com>.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -58,6 +58,7 @@
 #include "blocked.h"
 #include "conf.h"
 #include "errors.h"
+#include "test_util.h"
 
 
 #define EXPECTED_JOB_LOGDIR       "/var/log/upstart"
@@ -77,62 +78,40 @@
  */
 #define TEST_CMD_DD               "/bin/dd"
 
-/* Force an inotify watch update */
-#define TEST_FORCE_WATCH_UPDATE()                                    \
-{                                                                    \
-	int         nfds = 0;                                        \
-	int         ret = 0;                                         \
-	fd_set      readfds, writefds, exceptfds;                    \
-	                                                             \
-	FD_ZERO (&readfds);                                          \
-	FD_ZERO (&writefds);                                         \
-	FD_ZERO (&exceptfds);                                        \
-	                                                             \
-	nih_io_select_fds (&nfds, &readfds, &writefds, &exceptfds);  \
-	ret = select (nfds, &readfds, &writefds, &exceptfds, NULL);  \
-	if (ret > 0)                                                 \
-		nih_io_handle_fds (&readfds, &writefds, &exceptfds); \
-}
+/* number of iterations to perform to check file contents */
+#define MAX_ITERATIONS            5
 
-/* Force an inotify watch update (allowing a struct timeval
- * timeout to be specified
- */
-#define TEST_FORCE_WATCH_UPDATE_TIMEOUT(t)                           \
-{                                                                    \
-	int         nfds = 0;                                        \
-	int         ret = 0;                                         \
-	fd_set      readfds, writefds, exceptfds;                    \
-	                                                             \
-	FD_ZERO (&readfds);                                          \
-	FD_ZERO (&writefds);                                         \
-	FD_ZERO (&exceptfds);                                        \
-	                                                             \
-	nih_io_select_fds (&nfds, &readfds, &writefds, &exceptfds);  \
-	ret = select (nfds, &readfds, &writefds, &exceptfds, &t);    \
-	if (ret > 0)                                                 \
-		nih_io_handle_fds (&readfds, &writefds, &exceptfds); \
-}
-
-#define ENSURE_DIRECTORY_EMPTY(path)                                 \
-{                                                                    \
-	DIR            *dp = NULL;                                   \
-	struct dirent  *file = NULL;                                 \
-	int             count = 0;                                   \
-                                                                     \
-	dp = opendir (path);                                         \
-	TEST_NE_P (dp, NULL);                                        \
-                                                                     \
-	while((file = readdir (dp))) {                               \
-		if (!strcmp (".", file->d_name) ||                   \
-				!strcmp ("..", file->d_name))        \
-			continue;                                    \
-		count++;                                             \
-	}                                                            \
-                                                                     \
-	closedir (dp);                                               \
-                                                                     \
-	TEST_EQ (count, 0);                                          \
-}
+/**
+ * CHECK_FILE_EQ:
+ *
+ * @_file: FILE to read from,
+ * @_line: line to expect.
+ *
+ * Check that the next line in the file @_file is @_line, which should
+ * include the terminating newline if one is expected.
+ *
+ * This differs from TEST_FILE_EQ() in that the test is performed
+ * MAX_ITERATIONS times with a 1 second sleep between iterations.
+ **/
+#define CHECK_FILE_EQ(_file, _line, _select) \
+	do { \
+		int ok = FALSE; \
+		char filebuf[1024]; \
+		for (int i = 0; i < MAX_ITERATIONS; i++) { \
+			TEST_NE_P (fgets (filebuf, sizeof (filebuf), _file), NULL); \
+			if (! strcmp (filebuf, _line)) { \
+				ok = TRUE; \
+				break; \
+			} \
+			if (_select) { \
+				TEST_WATCH_UPDATE_TIMEOUT_SECS (1); \
+			} else { \
+				sleep (1); \
+			} \
+			rewind (_file); \
+		} \
+		TEST_EQ (ok, TRUE); \
+	} while (0)
 
 /* Sadly we can't test everything that job_process_spawn() does simply because
  * a lot of it can only be done by root, or in the case of the console stuff,
@@ -235,6 +214,13 @@
 		 */
 		fprintf(stdout, "stdout\n");
 		fprintf(stderr, "stderr\n");
+
+		/* write out pid to the output file to make it easier
+		 * for the caller to track us if we've already forked
+		 */
+		fprintf (out, "%d\n", getpid ());
+		
+		fflush (NULL);
 		break;
 	case TEST_OUTPUT_WITH_STOP:
 		fprintf (stdout, "started\n");
@@ -447,6 +433,7 @@
 	siginfo_t        siginfo;
 
 	log_unflushed_init ();
+	job_class_init ();
 
 	TEST_FUNCTION ("job_process_run");
 
@@ -466,6 +453,8 @@
 	 * finish and see that it has been run as expected.
 	 */
 	TEST_FEATURE ("with simple command");
+	TEST_HASH_EMPTY (job_classes);
+
 	TEST_ALLOC_FAIL {
 		TEST_ALLOC_SAFE {
 			class = job_class_new (NULL, "test", NULL);
@@ -499,6 +488,8 @@
 	 * check that a shell really was used.
 	 */
 	TEST_FEATURE ("with shell command");
+	TEST_HASH_EMPTY (job_classes);
+
 	TEST_ALLOC_FAIL {
 		TEST_ALLOC_SAFE {
 			class = job_class_new (NULL, "test", NULL);
@@ -537,6 +528,8 @@
 	 * command-line.
 	 */
 	TEST_FEATURE ("with small script");
+	TEST_HASH_EMPTY (job_classes);
+
 	TEST_ALLOC_FAIL {
 		TEST_ALLOC_SAFE {
 			class = job_class_new (NULL, "test", NULL);
@@ -575,6 +568,8 @@
 	 * to be stripped from the end before passing it on the command-line.
 	 */
 	TEST_FEATURE ("with small script and trailing newlines");
+	TEST_HASH_EMPTY (job_classes);
+
 	TEST_ALLOC_FAIL {
 		TEST_ALLOC_SAFE {
 			class = job_class_new (NULL, "test", NULL);
@@ -613,6 +608,8 @@
 	 * any failing command causes the entire script to fail.
 	 */
 	TEST_FEATURE ("with script that will fail");
+	TEST_HASH_EMPTY (job_classes);
+
 	TEST_ALLOC_FAIL {
 		TEST_ALLOC_SAFE {
 			class = job_class_new (NULL, "test", NULL);
@@ -651,6 +648,8 @@
 	 * with the job name appended to it.
 	 */
 	TEST_FEATURE ("with environment of unnamed instance");
+	TEST_HASH_EMPTY (job_classes);
+
 	TEST_ALLOC_FAIL {
 		TEST_ALLOC_SAFE {
 			class = job_class_new (NULL, "test", NULL);
@@ -702,6 +701,8 @@
 	 * with the job name and instance name appended to it.
 	 */
 	TEST_FEATURE ("with environment of named instance");
+	TEST_HASH_EMPTY (job_classes);
+
 	TEST_ALLOC_FAIL {
 		TEST_ALLOC_SAFE {
 			class = job_class_new (NULL, "test", NULL);
@@ -754,6 +755,8 @@
 	 * necessary, and the job name and id appended.
 	 */
 	TEST_FEATURE ("with environment for pre-stop");
+	TEST_HASH_EMPTY (job_classes);
+
 	TEST_ALLOC_FAIL {
 		TEST_ALLOC_SAFE {
 			class = job_class_new (NULL, "test", NULL);
@@ -807,6 +810,8 @@
 	 * necessary, and the job name and id appended.
 	 */
 	TEST_FEATURE ("with environment for post-stop");
+	TEST_HASH_EMPTY (job_classes);
+
 	TEST_ALLOC_FAIL {
 		TEST_ALLOC_SAFE {
 			class = job_class_new (NULL, "test", NULL);
@@ -860,6 +865,8 @@
 	 * child process by an NihIo structure.
 	 */
 	TEST_FEATURE ("with long script");
+	TEST_HASH_EMPTY (job_classes);
+
 	TEST_ALLOC_FAIL {
 		TEST_ALLOC_SAFE {
 			class = job_class_new (NULL, "test", NULL);
@@ -926,6 +933,8 @@
 	 * is reset and no process trace is established.
 	 */
 	TEST_FEATURE ("with non-daemon job");
+	TEST_HASH_EMPTY (job_classes);
+
 	TEST_ALLOC_FAIL {
 		TEST_ALLOC_SAFE {
 			class = job_class_new (NULL, "test", NULL);
@@ -963,6 +972,8 @@
 	 * trace state is reset and no process trace is established.
 	 */
 	TEST_FEATURE ("with script for daemon job");
+	TEST_HASH_EMPTY (job_classes);
+
 	TEST_ALLOC_FAIL {
 		TEST_ALLOC_SAFE {
 			class = job_class_new (NULL, "test", NULL);
@@ -1001,6 +1012,8 @@
 	 * follow the forks.
 	 */
 	TEST_FEATURE ("with daemon job");
+	TEST_HASH_EMPTY (job_classes);
+
 	TEST_ALLOC_FAIL {
 		TEST_ALLOC_SAFE {
 			class = job_class_new (NULL, "test", NULL);
@@ -1049,6 +1062,8 @@
 	 * follow the fork.
 	 */
 	TEST_FEATURE ("with forking job");
+	TEST_HASH_EMPTY (job_classes);
+
 	TEST_ALLOC_FAIL {
 		TEST_ALLOC_SAFE {
 			class = job_class_new (NULL, "test", NULL);
@@ -1096,6 +1111,8 @@
 	 * have any stored process id for it.
 	 */
 	TEST_FEATURE ("with no such file");
+	TEST_HASH_EMPTY (job_classes);
+
 	output = tmpfile ();
 
 	TEST_ALLOC_FAIL {
@@ -1127,6 +1144,8 @@
 		nih_free (class);
 	}
 
+	TEST_EQ (rmdir (dirname), 0);
+
 	TEST_FILENAME (dirname);       
 	TEST_EQ (mkdir (dirname, 0755), 0);
 
@@ -1138,6 +1157,8 @@
 	/************************************************************/
 	TEST_FEATURE ("ensure sane fds with no console, no script");
 
+	TEST_HASH_EMPTY (job_classes);
+
 	class = job_class_new (NULL, "prism", NULL);
 	TEST_NE_P (class, NULL);
 
@@ -1204,6 +1225,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("ensure sane fds with no console, and script");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "prism", NULL);
 	TEST_NE_P (class, NULL);
@@ -1271,6 +1293,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("ensure sane fds with console log, no script");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "prism", NULL);
 	TEST_NE_P (class, NULL);
@@ -1338,6 +1361,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("ensure sane fds with console log, and script");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "prism", NULL);
 	TEST_NE_P (class, NULL);
@@ -1405,6 +1429,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("ensure that no log file written for single-line no-output script");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "test", NULL);
 	TEST_NE_P (class, NULL);
@@ -1430,7 +1455,7 @@
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	ENSURE_DIRECTORY_EMPTY (dirname);
 
@@ -1441,6 +1466,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("ensure that no log file written for single-line no-output command");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "test", NULL);
 	TEST_NE_P (class, NULL);
@@ -1466,7 +1492,7 @@
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	ENSURE_DIRECTORY_EMPTY (dirname);
 
@@ -1477,6 +1503,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("ensure that no log file written for CONSOLE_NONE");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "test", NULL);
 	TEST_NE_P (class, NULL);
@@ -1511,7 +1538,7 @@
 		/* be generous */
 		t.tv_sec  = 2;
 		t.tv_usec = 0;
-		TEST_FORCE_WATCH_UPDATE_TIMEOUT (t);
+		TEST_WATCH_UPDATE_TIMEOUT (&t);
 	}
 
 	ENSURE_DIRECTORY_EMPTY (dirname);
@@ -1523,6 +1550,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("ensure that no log file written for multi-line no-output script");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "test", NULL);
 	TEST_NE_P (class, NULL);
@@ -1545,7 +1573,7 @@
 	TEST_NE (job->pid[PROCESS_MAIN], 0);
 
 	/* XXX: call 1: wait for script write to child shell */
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	waitpid (job->pid[PROCESS_MAIN], &status, 0);
 	TEST_TRUE (WIFEXITED (status));
@@ -1554,7 +1582,7 @@
 	TEST_EQ (WEXITSTATUS (status), 1);
 
 	/* XXX: call 2: wait for read from pty allowing logger to write to log file */
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	ENSURE_DIRECTORY_EMPTY (dirname);
 
@@ -1565,6 +1593,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line script that writes 1 line to stdout");
+	TEST_HASH_EMPTY (job_classes);
 
 	/* Note we can't use TEST_ALLOC_FAIL() for this test since on
 	 * the ENOMEM loop all we could do is discard the error and
@@ -1601,7 +1630,7 @@
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -1622,7 +1651,8 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "hello world\r\n");
+	CHECK_FILE_EQ (output, "hello world\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -1631,6 +1661,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line script that is killed");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "test", NULL);
 	TEST_NE_P (class, NULL);
@@ -1654,7 +1685,7 @@
 	TEST_NE (job->pid[PROCESS_MAIN], 0);
 
 	/*  wait for read from pty allowing logger to write to log file */
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (kill (-job->pid[PROCESS_MAIN], SIGKILL), 0);
 	waitpid (job->pid[PROCESS_MAIN], &status, 0);
@@ -1680,7 +1711,30 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "hello world\r\n");
+	/* This is very icky...
+	 *
+	 * Since we're not running an nih_main_loop, select(2) is
+	 * not being called for us. We have already called
+	 * select(2) once via TEST_WATCH_UPDATE() (since we expect
+	 * the job to have produced output) but we have absolutely
+	 * no way of knowing if it should be called again unless we have
+	 * a custom loop which calls select(2) and then checks for the
+	 * expected result. However, that would either mean
+	 * TEST_WATCH_UPDATE() could not be called "in isolation" or
+	 * that it would need to accept a block that could check some
+	 * condition to know whether to call select(2) again.
+	 *
+	 * For now, we cheat by re-reading the log file a number of
+	 * times. If we don't see the expected result within a
+	 * "reasonable" period, we fail.
+	 *
+	 * This loop is necessary since although the amount of data
+	 * being transferred is tiny, the kernel occasionally splits it
+	 * into multiple chunks using one of the line end characters as
+	 * a "delimiter".
+	 */
+	CHECK_FILE_EQ (output, "hello world\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -1689,6 +1743,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line command that is killed");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "test", NULL);
 	TEST_NE_P (class, NULL);
@@ -1714,7 +1769,7 @@
 	TEST_NE (job->pid[PROCESS_MAIN], 0);
 
 	/*  wait for read from pty allowing logger to write to log file */
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (kill (job->pid[PROCESS_MAIN], SIGKILL), 0);
 	waitpid (job->pid[PROCESS_MAIN], &status, 0);
@@ -1743,22 +1798,41 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	/* XXX: this _might_ be a kernel(?) bug - sometimes we don't read
-	 * the final line end character (presumably since the process
-	 * was forcibly killed).
+	/* Timed repeated read until we get the result we expect.
 	 */
+	ok = FALSE;
 	while (fgets (filebuf, sizeof(filebuf), output) != NULL) {
 		if (! strcmp (filebuf, "y\r\n"))
-			ok = 1;
-		else if (! strcmp (filebuf, "y") && feof (output))
-			ok = 1;
+			ok = TRUE;
 		else
-			ok = 0;
+			ok = FALSE;
 
 		if (! ok)
 			break;
 	}
-	TEST_EQ (ok, 1);
+
+	if (! ok) {
+		/* The last entry has been truncated, probably due to
+		 * the kernel breaking the data on one of the newline
+		 * characters. Attempt a few times to re-read all the
+		 * expected data.
+		 */
+		for (int i = 0; i < MAX_ITERATIONS; i++) {
+			/* rewind until 3 bytes ('y', '\r' and '\n')
+			 * before EOF.
+			 */
+			fseek (output, 3, SEEK_END);
+
+			TEST_NE_P (fgets (filebuf, sizeof (filebuf), output), NULL);
+			if (! strcmp (filebuf, "y\r\n")) {
+				ok = TRUE;
+				break;
+			}
+			sleep (1);
+			rewind (output);
+		}
+	}
+	TEST_EQ (ok, TRUE);
 
 	TEST_FILE_END (output);
 	fclose (output);
@@ -1767,6 +1841,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with multi-line script that is killed");
+	TEST_HASH_EMPTY (job_classes);
 
 	/* Note we can't use TEST_ALLOC_FAIL() for this test since on
 	 * the ENOMEM loop all we could do is discard the error and
@@ -1800,10 +1875,10 @@
 	TEST_NE (job->pid[PROCESS_MAIN], 0);
 
 	/* XXX: call 1: wait for script write to child shell */
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	/* XXX: call 2: wait for read from pty allowing logger to write to log file */
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (kill (-job->pid[PROCESS_MAIN], SIGKILL), 0);
 	waitpid (job->pid[PROCESS_MAIN], &status, 0);
@@ -1829,7 +1904,8 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "hello world\r\n");
+	CHECK_FILE_EQ (output, "hello world\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -1838,6 +1914,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line script that writes 1 byte and is killed");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "test", NULL);
 	TEST_NE_P (class, NULL);
@@ -1861,7 +1938,7 @@
 	TEST_NE (job->pid[PROCESS_MAIN], 0);
 
 	/*  wait for read from pty allowing logger to write to log file */
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (kill (-job->pid[PROCESS_MAIN], SIGKILL), 0);
 	waitpid (job->pid[PROCESS_MAIN], &status, 0);
@@ -1905,6 +1982,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with multi-line script that writes 1 byte and is killed");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "multiline", NULL);
 	TEST_NE_P (class, NULL);
@@ -1929,14 +2007,14 @@
 	TEST_NE (job->pid[PROCESS_MAIN], 0);
 
 	/* XXX: call 1: wait for script write to child shell */
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	waitpid (job->pid[PROCESS_MAIN], &status, 0);
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
 	/* XXX: call 2: wait for read from pty allowing logger to write to log file */
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -1966,6 +2044,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line command that writes 1 line to stdout");
+	TEST_HASH_EMPTY (job_classes);
 
 	/* Note we can't use TEST_ALLOC_FAIL() for this test since on
 	 * the ENOMEM loop all we could do is discard the error and
@@ -2002,7 +2081,7 @@
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -2023,7 +2102,8 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "hello world\r\n");
+	CHECK_FILE_EQ (output, "hello world\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -2032,10 +2112,11 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with multi-line script that writes 1 line to stdout");
+	TEST_HASH_EMPTY (job_classes);
 
 	/* XXX: Note that all tests which use multi-line scripts (but
 	 * XXX: *NOT* commands!) and produce output must call
-	 * XXX: TEST_FORCE_WATCH_UPDATE() *TWICE* to ensure select(2) is
+	 * XXX: TEST_WATCH_UPDATE() *TWICE* to ensure select(2) is
 	 * XXX: called twice.
 	 *
 	 * This is required since job_process_run() uses an NihIo object
@@ -2046,7 +2127,7 @@
 	 * associated with the pty which will trigger the log file to be
 	 * written.
 	 *
-	 * Note that the 2nd call to TEST_FORCE_WATCH_UPDATE would not be
+	 * Note that the 2nd call to TEST_WATCH_UPDATE would not be
 	 * required should job_process_run() simple invoke write(2) to
 	 * send the data.
 	 */
@@ -2074,14 +2155,14 @@
 	TEST_NE (job->pid[PROCESS_MAIN], 0);
 
 	/* XXX: call 1: wait for script write to child shell */
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	waitpid (job->pid[PROCESS_MAIN], &status, 0);
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
 	/* XXX: call 2: wait for read from pty allowing logger to write to log file */
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -2102,7 +2183,8 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "hello world\r\n");
+	CHECK_FILE_EQ (output, "hello world\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -2111,6 +2193,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with instance job and single-line script that writes 1 line to stdout");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "test", NULL);
 	TEST_NE_P (class, NULL);
@@ -2137,7 +2220,7 @@
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -2158,7 +2241,8 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "hello world\r\n");
+	CHECK_FILE_EQ (output, "hello world\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -2167,6 +2251,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line script that writes >1 lines to stdout");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "foo", NULL);
 	TEST_NE_P (class, NULL);
@@ -2195,7 +2280,7 @@
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -2219,9 +2304,10 @@
 	/* Yup, pseudo-terminals record *everything*,
 	 * even the carriage returns.
 	 */
-	TEST_FILE_EQ (output, "hello world\r\n");
-	TEST_FILE_EQ (output, "\r\n");
-	TEST_FILE_EQ (output, "\r\n");
+	CHECK_FILE_EQ (output, "hello world\r\n", TRUE);
+	CHECK_FILE_EQ (output, "\r\n", TRUE);
+	CHECK_FILE_EQ (output, "\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -2230,6 +2316,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line command that writes >1 lines to stdout");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "foo", NULL);
 	TEST_NE_P (class, NULL);
@@ -2258,7 +2345,7 @@
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -2279,9 +2366,10 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "hello world\r\n");
-	TEST_FILE_EQ (output, "\r\n");
-	TEST_FILE_EQ (output, "\r\n");
+	CHECK_FILE_EQ (output, "hello world\r\n", TRUE);
+	CHECK_FILE_EQ (output, "\r\n", TRUE);
+	CHECK_FILE_EQ (output, "\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -2290,6 +2378,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with multi-line script that writes >1 lines to stdout");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "elf", NULL);
 	TEST_NE_P (class, NULL);
@@ -2314,11 +2403,11 @@
 
 	TEST_NE (job->pid[PROCESS_MAIN], 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 	waitpid (job->pid[PROCESS_MAIN], &status, 0);
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -2339,9 +2428,10 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "hello world\r\n");
-	TEST_FILE_EQ (output, "\r\n");
-	TEST_FILE_EQ (output, "\r\n");
+	CHECK_FILE_EQ (output, "hello world\r\n", TRUE);
+	CHECK_FILE_EQ (output, "\r\n", TRUE);
+	CHECK_FILE_EQ (output, "\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -2350,6 +2440,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line script that writes 1 line to stderr");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "test", NULL);
 	TEST_NE_P (class, NULL);
@@ -2376,7 +2467,7 @@
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -2397,7 +2488,8 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "hello world\r\n");
+	CHECK_FILE_EQ (output, "hello world\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -2406,6 +2498,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line command that writes 1 line to stderr");
+	TEST_HASH_EMPTY (job_classes);
 
 	/* Run a command that generates output to stderr without having
 	 * to use script redirection.
@@ -2437,7 +2530,7 @@
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -2458,8 +2551,9 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "0+0 records in\r\n");
-	TEST_FILE_EQ (output, "0+0 records out\r\n");
+	CHECK_FILE_EQ (output, "0+0 records in\r\n", TRUE);
+	CHECK_FILE_EQ (output, "0+0 records out\r\n", TRUE);
+
 	TEST_FILE_MATCH (output, "0 bytes (0 B) copied,*\r\n");
 	TEST_FILE_END (output);
 	fclose (output);
@@ -2469,6 +2563,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with multi-line script that writes 1 line to stderr");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "test", NULL);
 	TEST_NE_P (class, NULL);
@@ -2491,13 +2586,13 @@
 
 	TEST_NE (job->pid[PROCESS_MAIN], 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	waitpid (job->pid[PROCESS_MAIN], &status, 0);
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -2518,7 +2613,8 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "hello world\r\n");
+	CHECK_FILE_EQ (output, "hello world\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -2527,6 +2623,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line script that writes >1 lines to stderr");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "foo", NULL);
 	TEST_NE_P (class, NULL);
@@ -2555,7 +2652,7 @@
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -2579,10 +2676,11 @@
 	/* Yup, pseudo-terminals record *everything*,
 	 * even the carriage returns.
 	 */
-	TEST_FILE_EQ (output, "hello\r\n");
-	TEST_FILE_EQ (output, "world\r\n");
-	TEST_FILE_EQ (output, "\r\n");
-	TEST_FILE_EQ (output, "\r\n");
+	CHECK_FILE_EQ (output, "hello\r\n", TRUE);
+	CHECK_FILE_EQ (output, "world\r\n", TRUE);
+	CHECK_FILE_EQ (output, "\r\n", TRUE);
+	CHECK_FILE_EQ (output, "\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -2591,6 +2689,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line command that writes >1 lines to stderr");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "foo", NULL);
 	TEST_NE_P (class, NULL);
@@ -2619,7 +2718,7 @@
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -2640,9 +2739,10 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "hello world\r\n");
-	TEST_FILE_EQ (output, "\r\n");
-	TEST_FILE_EQ (output, "\r\n");
+	CHECK_FILE_EQ (output, "hello world\r\n", TRUE);
+	CHECK_FILE_EQ (output, "\r\n", TRUE);
+	CHECK_FILE_EQ (output, "\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -2651,6 +2751,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with multi-line script that writes >1 lines to stderr");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "elf", NULL);
 	TEST_NE_P (class, NULL);
@@ -2675,13 +2776,13 @@
 
 	TEST_NE (job->pid[PROCESS_MAIN], 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	waitpid (job->pid[PROCESS_MAIN], &status, 0);
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -2702,8 +2803,9 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "hello world\r\n");
-	TEST_FILE_EQ (output, "\r\n");
+	CHECK_FILE_EQ (output, "hello world\r\n", TRUE);
+	CHECK_FILE_EQ (output, "\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -2712,6 +2814,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line script that writes 1 line to stdout then 1 line to stderr");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "blah", NULL);
 	TEST_NE_P (class, NULL);
@@ -2741,7 +2844,7 @@
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -2762,8 +2865,9 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "stdout\r\n");
-	TEST_FILE_EQ (output, "stderr\r\n");
+	CHECK_FILE_EQ (output, "stdout\r\n", TRUE);
+	CHECK_FILE_EQ (output, "stderr\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -2772,6 +2876,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line script that writes 1 line to stderr then 1 line to stdout");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "blah", NULL);
 	TEST_NE_P (class, NULL);
@@ -2801,7 +2906,7 @@
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -2822,8 +2927,9 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "stderr\r\n");
-	TEST_FILE_EQ (output, "stdout\r\n");
+	CHECK_FILE_EQ (output, "stderr\r\n", TRUE);
+	CHECK_FILE_EQ (output, "stdout\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -2832,6 +2938,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line command that writes to stdout and stderr");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "blah", NULL);
 	TEST_NE_P (class, NULL);
@@ -2859,7 +2966,7 @@
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -2885,7 +2992,7 @@
 	p = filebuf + 7;
 	TEST_EQ_STR (p, "7+0 records in\r\n");
 
-	TEST_FILE_EQ (output, "7+0 records out\r\n");
+	CHECK_FILE_EQ (output, "7+0 records out\r\n", TRUE);
 	TEST_FILE_MATCH (output, "7 bytes (7 B) copied,*\r\n");
 	TEST_FILE_END (output);
 	fclose (output);
@@ -2895,6 +3002,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line script running an invalid command");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "blah", NULL);
 	TEST_NE_P (class, NULL);
@@ -2922,7 +3030,7 @@
 	TEST_TRUE (WIFEXITED (status));
 	TEST_NE (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -2962,6 +3070,7 @@
 	 * had we originally tested this scenario!
 	 ************************************************************/
 	TEST_FEATURE ("with single-line command running an invalid command");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "buzz", NULL);
 	TEST_NE_P (class, NULL);
@@ -3002,6 +3111,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line command running an invalid command, then a 1-line post-stop script");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "asterix", NULL);
 	TEST_NE_P (class, NULL);
@@ -3055,7 +3165,7 @@
 		/* Flush the io so that the shell on the client side
 		 * gets the data (the script to execute).
 		 */
-		TEST_FORCE_WATCH_UPDATE ();
+		TEST_WATCH_UPDATE ();
 
 		waitpid (job->pid[PROCESS_POST_STOP], &status, 0);
 		TEST_TRUE (WIFEXITED (status));
@@ -3068,7 +3178,10 @@
 
 	/* check file contents */
 	output = fopen (filename, "r");
-	TEST_FILE_EQ (output, "hello\r\n");
+	TEST_NE_P (output, NULL);
+
+	CHECK_FILE_EQ (output, "hello\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -3078,6 +3191,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line command running an invalid command, then a 2-line post-stop script");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "asterix", NULL);
 	TEST_NE_P (class, NULL);
@@ -3131,14 +3245,14 @@
 		/* Flush the io so that the shell on the client side
 		 * gets the data (the script to execute).
 		 */
-		TEST_FORCE_WATCH_UPDATE ();
+		TEST_WATCH_UPDATE ();
 
 		waitpid (job->pid[PROCESS_POST_STOP], &status, 0);
 		TEST_TRUE (WIFEXITED (status));
 		TEST_EQ (WEXITSTATUS (status), 0);
 
 		/* Allow the log to be written */
-		TEST_FORCE_WATCH_UPDATE ();
+		TEST_WATCH_UPDATE ();
 
 		/* .. but the post stop should have written data */
 		TEST_EQ (stat (filename, &statbuf), 0);
@@ -3147,8 +3261,11 @@
 
 	/* check file contents */
 	output = fopen (filename, "r");
-	TEST_FILE_EQ (output, "hello\r\n");
-	TEST_FILE_EQ (output, "world\r\n");
+	TEST_NE_P (output, NULL);
+
+	CHECK_FILE_EQ (output, "hello\r\n", TRUE);
+	CHECK_FILE_EQ (output, "world\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -3158,6 +3275,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line command running an invalid command, then a post-stop command");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "asterix", NULL);
 	TEST_NE_P (class, NULL);
@@ -3211,7 +3329,7 @@
 		/* Flush the io so that the shell on the client side
 		 * gets the data (the script to execute).
 		 */
-		TEST_FORCE_WATCH_UPDATE ();
+		TEST_WATCH_UPDATE ();
 
 		waitpid (job->pid[PROCESS_POST_STOP], &status, 0);
 		TEST_TRUE (WIFEXITED (status));
@@ -3224,7 +3342,10 @@
 
 	/* check file contents */
 	output = fopen (filename, "r");
-	TEST_FILE_EQ (output, "hello\r\n");
+	TEST_NE_P (output, NULL);
+
+	CHECK_FILE_EQ (output, "hello\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -3234,6 +3355,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line command running an invalid command, then an invalid post-stop command");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "asterix", NULL);
 	TEST_NE_P (class, NULL);
@@ -3291,6 +3413,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single-line command running a valid command, then a 1-line invalid post-stop command");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "obelix", NULL);
 	TEST_NE_P (class, NULL);
@@ -3336,7 +3459,7 @@
 		/* Flush the io so that the shell on the client side
 		 * gets the data (the script to execute).
 		 */
-		TEST_FORCE_WATCH_UPDATE ();
+		TEST_WATCH_UPDATE ();
 
 		/* Expect a log file */
 		TEST_EQ (stat (filename, &statbuf), 0);
@@ -3353,7 +3476,10 @@
 
 	/* check file contents */
 	output = fopen (filename, "r");
-	TEST_FILE_EQ (output, "hello world\r\n");
+	TEST_NE_P (output, NULL);
+
+	CHECK_FILE_EQ (output, "hello world\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -3363,6 +3489,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with multi-line script running an invalid command");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "blah", NULL);
 	TEST_NE_P (class, NULL);
@@ -3386,11 +3513,11 @@
 
 	TEST_NE (job->pid[PROCESS_MAIN], 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 	waitpid (job->pid[PROCESS_MAIN], &status, 0);
 	TEST_TRUE (WIFEXITED (status));
 	TEST_NE (WEXITSTATUS (status), 0);
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -3422,6 +3549,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with multi-line script that writes 1 line to stdout then 1 line to stderr");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "blah", NULL);
 	TEST_NE_P (class, NULL);
@@ -3446,13 +3574,13 @@
 
 	TEST_NE (job->pid[PROCESS_MAIN], 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	waitpid (job->pid[PROCESS_MAIN], &status, 0);
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -3473,8 +3601,9 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "stdout\r\n");
-	TEST_FILE_EQ (output, "stderr\r\n");
+	CHECK_FILE_EQ (output, "stdout\r\n", TRUE);
+	CHECK_FILE_EQ (output, "stderr\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -3483,6 +3612,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with multi-line script that writes 1 line to stderr then 1 line to stdout");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "blah", NULL);
 	TEST_NE_P (class, NULL);
@@ -3507,13 +3637,13 @@
 
 	TEST_NE (job->pid[PROCESS_MAIN], 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	waitpid (job->pid[PROCESS_MAIN], &status, 0);
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -3534,8 +3664,9 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "stderr\r\n");
-	TEST_FILE_EQ (output, "stdout\r\n");
+	CHECK_FILE_EQ (output, "stderr\r\n", TRUE);
+	CHECK_FILE_EQ (output, "stdout\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -3549,6 +3680,7 @@
 	 * loop iteration_.
 	 */
 	TEST_FEATURE ("with single line command writing fast and exiting");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "budapest", NULL);
 	TEST_NE_P (class, NULL);
@@ -3611,7 +3743,8 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "hello\r\n");
+	CHECK_FILE_EQ (output, "hello\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -3619,6 +3752,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with single line command writing lots of data fast and exiting");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "foo", NULL);
 	TEST_NE_P (class, NULL);
@@ -3661,7 +3795,7 @@
 	TEST_EQ (kill (pid, 0), 0);
 
 	{
-		size_t  bytes;
+		size_t  bytes = 0;
 		size_t  expected_bytes = TEST_BLOCKSIZE * EXPECTED_1K_BLOCKS;
 		off_t   filesize = (off_t)-1;
 
@@ -3678,7 +3812,7 @@
 			t.tv_sec  = 1;
 			t.tv_usec = 0;
 
-			TEST_FORCE_WATCH_UPDATE_TIMEOUT (t);
+			TEST_WATCH_UPDATE_TIMEOUT (&t);
 
 			TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -3747,6 +3881,7 @@
 	/* Applies to respawn jobs too */
 
 	TEST_FEATURE ("with log object freed on process exit");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "acorn", NULL);
 	TEST_NE_P (class, NULL);
@@ -3828,6 +3963,7 @@
 	 * otherwise.
 	 */
 	TEST_FEATURE ("with setuid me");
+	TEST_HASH_EMPTY (job_classes);
 
 	TEST_NE_P (output, NULL);
 	TEST_ALLOC_FAIL {
@@ -3870,6 +4006,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with multiple processes and log");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "aero", NULL);
 	TEST_NE_P (class, NULL);
@@ -3913,7 +4050,7 @@
 	pid = job->pid[PROCESS_MAIN];
 	TEST_GT (pid, 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
@@ -3921,7 +4058,8 @@
 	TEST_NE_P (output, NULL);
 
 	/* initial output from main process */
-	TEST_FILE_EQ (output, "started\r\n");
+	CHECK_FILE_EQ (output, "started\r\n", TRUE);
+
 	TEST_FILE_END (output);
 
 	TEST_EQ (fclose (output), 0);
@@ -3936,7 +4074,7 @@
 	waitpid (pid, &status, 0);
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
@@ -3944,9 +4082,10 @@
 	/* initial output from main process, followed by all output from
 	 * post-start process.
 	 */
-	TEST_FILE_EQ (output, "started\r\n");
-	TEST_FILE_EQ (output, "stdout\r\n");
-	TEST_FILE_EQ (output, "stderr\r\n");
+	CHECK_FILE_EQ (output, "started\r\n", TRUE);
+	CHECK_FILE_EQ (output, "stdout\r\n", TRUE);
+	CHECK_FILE_EQ (output, "stderr\r\n", TRUE);
+
 	TEST_FILE_END (output);
 
 	TEST_EQ (fclose (output), 0);
@@ -3963,7 +4102,7 @@
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
@@ -3971,10 +4110,11 @@
 	/* initial output from main process, followed by all output from
 	 * post-start process, followed by final data from main process.
 	 */
-	TEST_FILE_EQ (output, "started\r\n");
-	TEST_FILE_EQ (output, "stdout\r\n");
-	TEST_FILE_EQ (output, "stderr\r\n");
-	TEST_FILE_EQ (output, "ended\r\n");
+	CHECK_FILE_EQ (output, "started\r\n", TRUE);
+	CHECK_FILE_EQ (output, "stdout\r\n", TRUE);
+	CHECK_FILE_EQ (output, "stderr\r\n", TRUE);
+	CHECK_FILE_EQ (output, "ended\r\n", TRUE);
+
 	TEST_FILE_END (output);
 
 	TEST_EQ (fclose (output), 0);
@@ -3987,6 +4127,7 @@
 
 	TEST_EQ (rmdir (dirname), 0);
 	TEST_EQ (unsetenv ("UPSTART_LOGDIR"), 0);
+	TEST_HASH_EMPTY (job_classes);
 }
 
 
@@ -4045,6 +4186,8 @@
 	 * that the process tree is what we expect it to look like.
 	 */
 	TEST_FEATURE ("with simple job");
+	TEST_HASH_EMPTY (job_classes);
+
 	sprintf (function, "%d", TEST_PIDS);
 
 	class = job_class_new (NULL, "test", NULL);
@@ -4075,7 +4218,7 @@
 	TEST_FILE_END (output);
 
 	fclose (output);
-	unlink (filename);
+	assert0 (unlink (filename));
 
 	nih_free (class);
 
@@ -4084,6 +4227,8 @@
 	 * bound to the /dev/null device.
 	 */
 	TEST_FEATURE ("with no console");
+	TEST_HASH_EMPTY (job_classes);
+
 	sprintf (function, "%d", TEST_CONSOLE);
 
 	class = job_class_new (NULL, "test", NULL);
@@ -4102,7 +4247,7 @@
 	TEST_FILE_END (output);
 
 	fclose (output);
-	unlink (filename);
+	assert0 (unlink (filename));
 
 	nih_free (class);
 
@@ -4114,6 +4259,8 @@
 	 *
 	 */
 	TEST_FEATURE ("with console logging");
+	TEST_HASH_EMPTY (job_classes);
+
 	sprintf (function, "%d", TEST_CONSOLE);
 
 	class = job_class_new (NULL, "test", NULL);
@@ -4149,7 +4296,7 @@
 	TEST_FILE_END (output);
 
 	fclose (output);
-	unlink (filename);
+	assert0 (unlink (filename));
 
 	nih_free (class);
 
@@ -4158,6 +4305,8 @@
 	 * that directory.
 	 */
 	TEST_FEATURE ("with working directory");
+	TEST_HASH_EMPTY (job_classes);
+
 	sprintf (function, "%d", TEST_PWD);
 
 	class = job_class_new (NULL, "test", NULL);
@@ -4175,7 +4324,7 @@
 	TEST_FILE_END (output);
 
 	fclose (output);
-	unlink (filename);
+	assert0 (unlink (filename));
 
 	nih_free (class);
 
@@ -4184,6 +4333,8 @@
 	 * specifiec in the function call.
 	 */
 	TEST_FEATURE ("with environment");
+	TEST_HASH_EMPTY (job_classes);
+
 	sprintf (function, "%d", TEST_ENVIRONMENT);
 	setenv ("BAR", "baz", TRUE);
 
@@ -4207,7 +4358,7 @@
 	TEST_FILE_END (output);
 
 	fclose (output);
-	unlink (filename);
+	assert0 (unlink (filename));
 
 	nih_free (class);
 
@@ -4217,6 +4368,8 @@
 	 * to fork.
 	 */
 	TEST_FEATURE ("with non-daemon job");
+	TEST_HASH_EMPTY (job_classes);
+
 	sprintf (function, "%d", TEST_SIMPLE);
 
 	class = job_class_new (NULL, "test", NULL);
@@ -4230,7 +4383,7 @@
 	TEST_EQ (info.si_code, CLD_EXITED);
 	TEST_EQ (info.si_status, 0);
 
-	unlink (filename);
+	assert0 (unlink (filename));
 
 	nih_free (class);
 
@@ -4239,6 +4392,8 @@
 	 * parent be traced.
 	 */
 	TEST_FEATURE ("with daemon job");
+	TEST_HASH_EMPTY (job_classes);
+
 	sprintf (function, "%d", TEST_SIMPLE);
 
 	class = job_class_new (NULL, "test", NULL);
@@ -4257,7 +4412,7 @@
 	TEST_EQ (info.si_code, CLD_EXITED);
 	TEST_EQ (info.si_status, 0);
 
-	unlink (filename);
+	assert0 (unlink (filename));
 
 	nih_free (class);
 
@@ -4267,6 +4422,8 @@
 	 * error structure.
 	 */
 	TEST_FEATURE ("with no such file");
+	TEST_HASH_EMPTY (job_classes);
+
 	args[0] = filename;
 	args[1] = filename;
 	args[2] = NULL;
@@ -4290,6 +4447,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with no such file, no shell and console log");
+	TEST_HASH_EMPTY (job_classes);
 
 	args[0] = "does-not-exist";
 	args[1] = NULL;
@@ -4323,6 +4481,7 @@
 	/* Check that we can spawn a job and pause it
 	 */
 	TEST_FEATURE ("with debug enabled");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "test", NULL);
 	class->console = CONSOLE_NONE;
@@ -4360,6 +4519,7 @@
 	 * signals are blocked or ignored.
 	 */
 	TEST_FEATURE ("ensure sane signal state with no console");
+	TEST_HASH_EMPTY (job_classes);
 
 	sprintf (function, "%d", TEST_SIGNALS);
 
@@ -4397,12 +4557,13 @@
 	}
 
 	fclose (output);
-	unlink (filename);
+	assert0 (unlink (filename));
 
 	nih_free (class);
 
 	/********************************************************************/
 	TEST_FEATURE ("ensure sane signal state with log console");
+	TEST_HASH_EMPTY (job_classes);
 
 	sprintf (function, "%d", TEST_SIGNALS);
 
@@ -4440,12 +4601,13 @@
 	}
 
 	fclose (output);
-	unlink (filename);
+	assert0 (unlink (filename));
 
 	nih_free (class);
 
 	/********************************************************************/
 	TEST_FEATURE ("ensure sane fds with no console");
+	TEST_HASH_EMPTY (job_classes);
 
 	sprintf (function, "%d", TEST_FDS);
 
@@ -4494,12 +4656,13 @@
 	}
 
 	fclose (output);
-	unlink (filename);
+	assert0 (unlink (filename));
 
 	nih_free (class);
 
 	/********************************************************************/
 	TEST_FEATURE ("ensure sane fds with console log");
+	TEST_HASH_EMPTY (job_classes);
 
 	sprintf (function, "%d", TEST_FDS);
 
@@ -4548,12 +4711,15 @@
 	}
 
 	fclose (output);
-	unlink (filename);
+	assert0 (unlink (filename));
+	TEST_EQ (rmdir (dirname), 0);
 
 	nih_free (class);
 
 	/************************************************************/
 	TEST_FEATURE ("ensure multi process output logged");
+	TEST_LIST_EMPTY (nih_io_watches);
+	TEST_HASH_EMPTY (job_classes);
 
 	TEST_FILENAME (dirname);       
 	TEST_EQ (mkdir (dirname, 0755), 0);
@@ -4590,14 +4756,15 @@
 	/* The main process is now running, but paused. It should have
 	 * produced some output so check that now.
 	 */
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (stat (filename, &statbuf), 0);
 
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "started\r\n");
+	CHECK_FILE_EQ (output, "started\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	TEST_EQ (fclose (output), 0);
 
@@ -4625,9 +4792,15 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "started\r\n"); /* from main process */
-	TEST_FILE_EQ (output, "stdout\r\n"); /* from post-start process */
-	TEST_FILE_EQ (output, "stderr\r\n"); /* from post-start process */
+	/* from main process */
+	CHECK_FILE_EQ (output, "started\r\n", TRUE);
+
+	/* from post-start process */
+	CHECK_FILE_EQ (output, "stdout\r\n", TRUE);
+
+	/* from post-start process */
+	CHECK_FILE_EQ (output, "stderr\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
@@ -4646,20 +4819,32 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "started\r\n"); /* from main process */
-	TEST_FILE_EQ (output, "stdout\r\n");  /* from post-start process */
-	TEST_FILE_EQ (output, "stderr\r\n");  /* from post-start process */
-	TEST_FILE_EQ (output, "ended\r\n");   /* from main process */
+	/* from main process */
+	CHECK_FILE_EQ (output, "started\r\n", TRUE);
+
+	/* from post-start process */
+	CHECK_FILE_EQ (output, "stdout\r\n", TRUE);
+
+	/* from post-start process */
+	CHECK_FILE_EQ (output, "stderr\r\n", TRUE);
+
+	/* from main process */
+	CHECK_FILE_EQ (output, "ended\r\n", TRUE);
+
 	TEST_FILE_END (output);
 	fclose (output);
 
-	TEST_EQ (unlink (filebuf), 0);
-	TEST_EQ (unlink (filename), 0);
+	assert0 (unlink (filebuf));
+	assert0 (unlink (filename));
+	TEST_EQ (rmdir (dirname), 0);
 
 	TEST_EQ (unsetenv ("UPSTART_LOGDIR"), 0);
 
+	nih_free (class);
+
 	/************************************************************/
 	TEST_FEATURE ("simple test");
+	TEST_HASH_EMPTY (job_classes);
 
 	TEST_FILENAME (dirname);       
 	umask(0);
@@ -4671,7 +4856,6 @@
 			class = job_class_new (NULL, "simple-test", NULL);
 			TEST_NE_P (class, NULL);
 
-			TEST_GT (sprintf (filename, "%s/simple-test.log", dirname), 0);
 			job = job_new (class, "");
 			TEST_NE_P (job, NULL);
 
@@ -4697,10 +4881,9 @@
 			TEST_NE_P (err, NULL);
 			TEST_EQ (err->number, ENOMEM);
 			nih_free (err);
+			assert0 (unlink (script));
 		} else {
 			TEST_GT (pid, 0);
-			TEST_EQ (unlink (script), 0);
-			unlink (filename);
 		}
 
 		TEST_ALLOC_SAFE {
@@ -4709,8 +4892,11 @@
 		}
 	}
 
+	assert0 (rmdir (dirname));
+
 	/************************************************************/
 	TEST_FEATURE ("with single-line script and 'console log'");
+	TEST_HASH_EMPTY (job_classes);
 
 	/* Check that we can spawn a job and retrieve its output.
 	 */
@@ -4750,25 +4936,27 @@
 	TEST_EQ (waitpid (pid, &status, 0), pid);
 	TEST_TRUE (WIFEXITED (status));
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "hello world\r\n");
+	CHECK_FILE_EQ (output, "hello world\r\n", TRUE);
+
 	TEST_FILE_END (output);
 
 	TEST_EQ (fclose (output), 0);
 
-	unlink (filename);
-
+	assert0 (unlink (filename));
+	assert0 (unlink (script));
 	TEST_EQ (rmdir (dirname), 0);
 	TEST_EQ (unsetenv ("UPSTART_LOGDIR"), 0);
 
-	nih_free (job);
+	nih_free (class);
 
 	/************************************************************/
 	TEST_FEATURE ("with multi-line script and 'console log'");
+	TEST_HASH_EMPTY (job_classes);
 
 	/* Check that we can spawn a job and retrieve its output.
 	 */
@@ -4804,17 +4992,19 @@
 	TEST_EQ (waitpid (pid, &status, 0), pid);
 	TEST_TRUE (WIFEXITED (status));
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "hello world\r\n");
+	CHECK_FILE_EQ (output, "hello world\r\n", TRUE);
+
 	TEST_FILE_END (output);
 
 	TEST_EQ (fclose (output), 0);
 
-	TEST_EQ (unlink (filename), 0);
+	assert0 (unlink (filename));
+	assert0 (unlink (script));
 
 	TEST_EQ (rmdir (dirname), 0);
 	TEST_EQ (unsetenv ("UPSTART_LOGDIR"), 0);
@@ -4823,6 +5013,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("read single null byte with 'console log'");
+	TEST_HASH_EMPTY (job_classes);
 
 	/* Check that we can spawn a job and read a single byte written
 	 * to stdout.
@@ -4866,7 +5057,7 @@
 
 	TEST_EQ (fclose (output), 0);
 
-	unlink (filename);
+	assert0 (unlink (filename));
 
 	TEST_EQ (rmdir (dirname), 0);
 	TEST_EQ (unsetenv ("UPSTART_LOGDIR"), 0);
@@ -4876,6 +5067,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("read data from forked process");
+	TEST_HASH_EMPTY (job_classes);
 
 	TEST_FILENAME (dirname);
 	umask(0);
@@ -4905,36 +5097,40 @@
 	pid = job_process_spawn (job, args, NULL, FALSE, -1, PROCESS_MAIN);
 	TEST_GT (pid, 0);
 
-	TEST_EQ (waitpid (pid, &status, 0), pid);
+	TEST_NE (waitpid (pid, &status, 0), -1);
 	TEST_TRUE (WIFEXITED (status));
 	TEST_EQ (WEXITSTATUS (status), 0);
 
 	ret = log_handle_unflushed (job->log, job->log[PROCESS_MAIN]);
 	TEST_EQ (ret, 1);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	/* This will eventually call the log destructor */
 	nih_free (class);
 
+	TEST_LIST_EMPTY (nih_io_watches);
+
 	TEST_EQ (stat (filename, &statbuf), 0);
 
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "stdout\r\n");
-	TEST_FILE_EQ (output, "stderr\r\n");
+	CHECK_FILE_EQ (output, "stdout\r\n", FALSE);
+	CHECK_FILE_EQ (output, "stderr\r\n", FALSE);
+
 	TEST_FILE_END (output);
 
 	TEST_EQ (fclose (output), 0);
 
-	unlink (filename);
+	assert0 (unlink (filename));
 
 	TEST_EQ (rmdir (dirname), 0);
 	TEST_EQ (unsetenv ("UPSTART_LOGDIR"), 0);
 
 	/************************************************************/
 	TEST_FEATURE ("read data from daemon process");
+	TEST_HASH_EMPTY (job_classes);
 
 	TEST_FILENAME (dirname);       
 	umask(0);
@@ -4964,7 +5160,7 @@
 	pid = job_process_spawn (job, args, NULL, FALSE, -1, PROCESS_MAIN);
 	TEST_GT (pid, 0);
 
-	TEST_FORCE_WATCH_UPDATE ();
+	TEST_WATCH_UPDATE ();
 
 	TEST_EQ (waitpid (pid, &status, 0), pid);
 	TEST_TRUE (WIFEXITED (status));
@@ -4976,13 +5172,14 @@
 	output = fopen (filename, "r");
 	TEST_NE_P (output, NULL);
 
-	TEST_FILE_EQ (output, "stdout\r\n");
-	TEST_FILE_EQ (output, "stderr\r\n");
+	CHECK_FILE_EQ (output, "stdout\r\n", FALSE);
+	CHECK_FILE_EQ (output, "stderr\r\n", FALSE);
+
 	TEST_FILE_END (output);
 
 	TEST_EQ (fclose (output), 0);
 
-	unlink (filename);
+	assert0 (unlink (filename));
 
 	TEST_EQ (rmdir (dirname), 0);
 	TEST_EQ (unsetenv ("UPSTART_LOGDIR"), 0);
@@ -4991,6 +5188,7 @@
 #if 0
 	/************************************************************/
 	TEST_FEATURE ("when no free ptys");
+	TEST_HASH_EMPTY (job_classes);
 	{
 		int            available_ptys;
 		int            ret;
@@ -5053,6 +5251,7 @@
 		}
 		nih_free (class);
 	}
+	assert0 (rmdir (dirname));
 #else
 		/* FIXME */
 		TEST_FEATURE ("WARNING: FIXME: test 'when no free ptys' disabled due to kernel bug");
@@ -5077,6 +5276,7 @@
 
 	/************************************************************/
 	TEST_FEATURE ("with system job with simple name");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "system", NULL);
 	TEST_NE_P (class, NULL);
@@ -5089,10 +5289,11 @@
 	expected = NIH_MUST (nih_sprintf (NULL, "%s/%s.log",
 				EXPECTED_JOB_LOGDIR, "system"));
 	TEST_EQ_STR (log_path, expected);
-	nih_free (job);
+	nih_free (class);
 
 	/************************************************************/
 	TEST_FEATURE ("with system job containing illegal path characters");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "//hello_foo bar.z/", NULL);
 	TEST_NE_P (class, NULL);
@@ -5105,10 +5306,11 @@
 	expected = NIH_MUST (nih_sprintf (NULL, "%s/%s.log",
 				EXPECTED_JOB_LOGDIR, "__hello_foo bar.z_"));
 	TEST_EQ_STR (log_path, expected);
-	nih_free (job);
+	nih_free (class);
 
 	/************************************************************/
 	TEST_FEATURE ("with system job with named instance");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "foo bar", NULL);
 	TEST_NE_P (class, NULL);
@@ -5121,10 +5323,11 @@
 	expected = NIH_MUST (nih_sprintf (NULL, "%s/%s.log",
 				EXPECTED_JOB_LOGDIR, "foo bar-bar foo"));
 	TEST_EQ_STR (log_path, expected);
-	nih_free (job);
+	nih_free (class);
 
 	/************************************************************/
 	TEST_FEATURE ("with system job with named instance and illegal path characters");
+	TEST_HASH_EMPTY (job_classes);
 
 	class = job_class_new (NULL, "a/b", NULL);
 	TEST_NE_P (class, NULL);
@@ -5137,10 +5340,11 @@
 	expected = NIH_MUST (nih_sprintf (NULL, "%s/%s.log",
 				EXPECTED_JOB_LOGDIR, "a_b-c_d_?_"));
 	TEST_EQ_STR (log_path, expected);
-	nih_free (job);
+	nih_free (class);
 
 	/************************************************************/
 	TEST_FEATURE ("with subverted logdir and system job with named instance and illegal path characters");
+	TEST_HASH_EMPTY (job_classes);
 
 	TEST_EQ (setenv ("UPSTART_LOGDIR", dirname, 1), 0);
 
@@ -5155,9 +5359,10 @@
 	expected = NIH_MUST (nih_sprintf (NULL, "%s/%s.log",
 				dirname, "a_b-c_d_?_"));
 	TEST_EQ_STR (log_path, expected);
-	nih_free (job);
+	nih_free (class);
 
 	TEST_EQ (unsetenv ("UPSTART_LOGDIR"), 0);
+	TEST_HASH_EMPTY (job_classes);
 }
 
 
@@ -8485,6 +8690,7 @@
 	nih_free (event);
 	event_poll ();
 
+	TEST_EQ (rmdir (dirname), 0);
 	TEST_EQ (unsetenv ("UPSTART_LOGDIR"), 0);
 }
 
@@ -8853,6 +9059,8 @@
 
 		nih_free (job);
 	}
+
+	unlink (utmpname);
 }
 
 
@@ -8888,17 +9096,27 @@
 	 * the number of times to fork.
 	 */
 	if (argc == 4) {
-		int forks = atol (argv[3]);
+		int    forks;
+		int    status;
+		pid_t  pid;
+
+		forks = atol (argv[3]);
+
 		nih_assert (forks > 0);
 
 		do {
-			if (fork () != 0)
+			pid = fork ();
+			if (pid < 0)
+				exit (1);
+			else if (pid) {
+				nih_assert (waitpid (pid, &status, 0) == pid);
 				exit (0);
+			}
 
 		} while (forks--);
 
 		child (atoi (argv[1]), argv[2]);
-		exit (1);
+		nih_assert_not_reached ();
 	}
 
 	/* If two arguments are given, the first is the child enum and the
--- upstart-1.5.orig/init/tests/test_util.c
+++ upstart-1.5/init/tests/test_util.c
@@ -0,0 +1,27 @@
+#include "test_util.h"
+
+/**
+ * string_check:
+ *
+ * @a: first string,
+ * @b: second string.
+ *
+ * Compare @a and @b either or both of which may be NULL.
+ *
+ * Returns 0 if strings are identical or both NULL, else 1.
+ **/
+int
+string_check (const char *a, const char *b)
+{
+	if (!a && !b)
+		return 0;
+
+	if (!a || !b)
+		return 1;
+
+	if (strcmp (a, b))
+		return 1;
+
+	return 0;
+}
+
--- upstart-1.5.orig/init/tests/test_util.h
+++ upstart-1.5/init/tests/test_util.h
@@ -0,0 +1,304 @@
+#ifndef TEST_UTIL_H
+#define TEST_UTIL_H
+
+#include <string.h>
+
+/* TEST_ENSURE_CLEAN_ENV:
+ *
+ * Ensure the environment is as pristine as possible (to avoid follow-on
+ * errors caused by not freeing objects in a previous test, say)
+ */
+#define TEST_ENSURE_CLEAN_ENV()                                      \
+{                                                                    \
+	setvbuf(stdout, NULL, _IONBF, 0);                            \
+                                                                     \
+	if (job_classes) {                                           \
+		TEST_HASH_EMPTY (job_classes);                       \
+	}                                                            \
+                                                                     \
+	if (conf_sources) {                                          \
+		TEST_LIST_EMPTY (conf_sources);                      \
+	}                                                            \
+                                                                     \
+	if (nih_io_watches) {                                        \
+		TEST_LIST_EMPTY (nih_io_watches);                    \
+	}                                                            \
+                                                                     \
+	if (nih_timers) {                                            \
+		TEST_LIST_EMPTY (nih_timers);                        \
+	}                                                            \
+                                                                     \
+	if (events) {                                                \
+		TEST_LIST_EMPTY (events);                            \
+	}                                                            \
+}
+
+/**
+ * _TEST_WATCH_UPDATE:
+ * @force: if TRUE, force an update,
+ * @timeout: struct timeval pointer, or NULL if no timeout required.
+ *
+ * Request NIH look for a file event relating to any NihIo objects,
+ * with an optional timeout. Behaviour can be forced via @force.
+ **/
+#define _TEST_WATCH_UPDATE(force, timeout)                           \
+{                                                                    \
+	int         nfds = 0;                                        \
+	int         ret = 0;                                         \
+	fd_set      readfds, writefds, exceptfds;                    \
+	                                                             \
+	FD_ZERO (&readfds);                                          \
+	FD_ZERO (&writefds);                                         \
+	FD_ZERO (&exceptfds);                                        \
+	                                                             \
+	nih_io_select_fds (&nfds, &readfds, &writefds, &exceptfds);  \
+	if (! force) {                                               \
+	  ret = select (nfds, &readfds, &writefds,                   \
+			&exceptfds, timeout);                        \
+	}                                                            \
+	if (force || ret > 0)                                        \
+		nih_io_handle_fds (&readfds, &writefds, &exceptfds); \
+}
+
+/**
+ * TEST_WATCH_UPDATE:
+ *
+ * Request NIH look for a file event relating to any NihIo objects,
+ * */
+#define TEST_WATCH_UPDATE()                                          \
+	_TEST_WATCH_UPDATE (0, NULL)
+
+/**
+ * TEST_WATCH_UPDATE_TIMEOUT:
+ * @timeout: struct timeval pointer.
+ *
+ * Request NIH look for a file event relating to any NihIo objects
+ * within time period @timeout.
+ **/
+#define TEST_WATCH_UPDATE_TIMEOUT(timeout)                           \
+	_TEST_WATCH_UPDATE (0, timeout)
+
+/**
+ * TEST_WATCH_UPDATE_TIMEOUT_SECS:
+ * @secs: seconds to wait before timeout.
+ *
+ * Request NIH look for a file event relating to any NihIo objects
+ * within @secs timeout.
+ **/
+#define TEST_WATCH_UPDATE_TIMEOUT_SECS(secs)                         \
+{                                                                    \
+	struct timeval _t;                                           \
+	_t.tv_sec  = secs;                                           \
+	_t.tv_usec = 0;                                              \
+	_TEST_WATCH_UPDATE (0, &_t);                                 \
+}
+
+/**
+ * TEST_FORCE_WATCH_UPDATE:
+ *
+ * Force NIH to look for a file event relating to any NihIo objects.
+ **/
+#define TEST_FORCE_WATCH_UPDATE()                                    \
+	_TEST_WATCH_UPDATE (1, NULL)
+
+/**
+ * TEST_FORCE_WATCH_UPDATE_TIMEOUT:
+ * @timeout: struct timeval pointer.
+ *
+ * Force NIH to look for a file event relating to any NihIo objects
+ * within time period @timeout.
+ **/
+#define TEST_FORCE_WATCH_UPDATE_TIMEOUT(timeout)                     \
+	_TEST_WATCH_UPDATE (1, timeout)
+
+/**
+ * TEST_FORCE_WATCH_UPDATE_TIMEOUT_SECS:
+ * @timeout: struct timeval pointer.
+ *
+ * Force NIH to look for a file event relating to any NihIo objects
+ * within time period @timeout.
+ **/
+#define TEST_FORCE_WATCH_UPDATE_TIMEOUT_SECS(secs)                   \
+{                                                                    \
+	struct timeval _t;                                           \
+	_t.tv_sec  = secs;                                           \
+	_t.tv_usec = 0;                                              \
+	_TEST_WATCH_UPDATE (1, &_t);                                 \
+}
+
+/**
+ * ENSURE_DIRECTORY_EMPTY:
+ * @path: Full path to a directory.
+ *
+ * Ensure specified directory is empty.
+ **/
+#define ENSURE_DIRECTORY_EMPTY(path)                                 \
+{                                                                    \
+	DIR            *dp = NULL;                                   \
+	struct dirent  *file = NULL;                                 \
+	int             count = 0;                                   \
+                                                                     \
+	dp = opendir (path);                                         \
+	TEST_NE_P (dp, NULL);                                        \
+                                                                     \
+	while((file = readdir (dp))) {                               \
+		if (!strcmp (".", file->d_name) ||                   \
+				!strcmp ("..", file->d_name))        \
+			continue;                                    \
+		count++;                                             \
+	}                                                            \
+                                                                     \
+	closedir (dp);                                               \
+                                                                     \
+	TEST_EQ (count, 0);                                          \
+}
+
+/**
+ * obj_string_check:
+ *
+ * @a: first object,
+ * @b: second object,
+ * @name: name of string element.
+ *
+ * Compare string element @name in objects @a and @b.
+ *
+ * Returns: 0 if strings are identical
+ * (or both NULL), else 1.
+ **/
+#define obj_string_check(a, b, name) \
+	string_check ((a)->name, (b)->name)
+
+/**
+ * obj_num_check:
+ *
+ * @a: first object,
+ * @b: second object.
+ * @name: name of numeric element.
+ *
+ * Compare numeric element @name in objects @a and @b.
+ *
+ * Returns: 0 if @a and @b are identical, else 1.
+ **/
+#define obj_num_check(a, b, name) \
+	(a->name != b->name)
+
+/**
+ * TEST_CMP_INT_ARRAYS:
+ * @a: first array,
+ * @b: second array,
+ * @sizea: size of @a,
+ * @sizeb: size of @b.
+ *
+ * Compare integer arrays @a and @b for equivalence.
+ *
+ * Returns: 0 if arrays are identical, else -1.
+ **/
+#define TEST_CMP_INT_ARRAYS(a, b, sizea, sizeb) \
+({int ret = 0; \
+ size_t __i; \
+ if (sizea == sizeb) { \
+	 for (__i = 0; \
+		 __i < sizea; \
+		 __i++) { \
+	 	if ((a)[__i] != (b)[__i]) { \
+ 			ret = -1; \
+ 			break; \
+ 		} \
+ 	} \
+ } else \
+ 	ret = -1; \
+ ret;})
+
+/**
+ * TEST_CMP_STR_ARRAYS:
+ * @a: first string array,
+ * @b: second string array,
+ * @sizea: length of @a, 
+ * @sizeb: length of @b.
+ *
+ * Compare string arrays @a and @b for equivalence.
+ *
+ * Returns: 0 if arrays are identical, else -1.
+ **/
+#define TEST_CMP_STR_ARRAYS(a, b, sizea, sizeb) \
+({ int ret = 0; \
+ if (sizea == sizeb) { \
+	 for (size_t __i = 0; \
+		 __i < sizea; \
+		 __i++) { \
+	 	if (strcmp (a[__i], b[__i])) { \
+ 			ret = -1; \
+ 			break; \
+ 		} \
+ 	} \
+ } else \
+ 	ret = -1; \
+ ret;})
+
+/**
+ * TEST_TWO_LISTS_FOREACH:
+ * @list1: entry in the first list to iterate,
+ * @list2: entry in the second list to iterate,
+ * @iter1: name of iterator variable for @list1,
+ * @iter2: name of iterator variable for @list2.
+ *
+ * Dual version of NIH_LIST_FOREACH() which iterates 
+ * two lists in tandem.
+ **/
+#define TEST_TWO_LISTS_FOREACH(list1, list2, iter1, iter2) \
+	for (NihList *iter1 = (list1)->next, \
+		     *iter2 = (list2)->next; \
+		iter1 != (list1) && iter2 != (list2); \
+		iter1 = iter1->next, \
+		iter2 = iter2->next)
+
+/**
+ * TEST_TWO_HASHES_FOREACH:
+ * @hash1: entry in the first hash to iterate,
+ * @hash2: entry in the second hash to iterate,
+ * @iter1: name of iterator variable for @hash1,
+ * @iter2: name of iterator variable for @hash2.
+ *
+ * Dual version of NIH_HASH_FOREACH() which iterates
+ * two hashes in tandem.
+ **/
+#define TEST_TWO_HASHES_FOREACH(hash1, hash2, iter1, iter2) \
+	for (size_t _##iter##_i = 0; _##iter##_i < (hash1)->size; \
+	     _##iter##_i++) \
+		TEST_TWO_LISTS_FOREACH (&(hash1)->bins[_##iter##_i], \
+					&(hash2)->bins[_##iter##_i], \
+				iter1, iter2)
+
+/**
+ * TEST_TWO_TREES_FOREACH:
+ * @tree1: root of the first tree to iterate,
+ * @tree2: root of the second tree to iterate,
+ * @iter1: name of iterator variable for @tree1,
+ * @iter2: name of iterator variable for @tree2.
+ *
+ * Dual version of NIH_TREE_FOREACH() which walks
+ * two trees in tandem.
+ **/
+#define TEST_TWO_TREES_FOREACH(tree1, tree2, iter1, iter2) \
+	for (NihTree *iter1 = nih_tree_next (tree1, NULL), \
+			*iter2 = nih_tree_next (tree2, NULL); \
+			iter1 != NULL && iter2 != NULL; \
+			iter1 = nih_tree_next (tree1, iter1), \
+			iter2 = nih_tree_next (tree2, iter2))
+
+
+/**
+ * TEST_ARRAY_SIZE:
+ * @array: array.
+ * 
+ * Determine size of specified array.
+ *
+ * Returns: array size.
+ **/
+#define TEST_ARRAY_SIZE(array) \
+	(sizeof (array) / sizeof (array[0]))
+
+/* Prototypes */
+extern int string_check (const char *a, const char *b);
+
+#endif /* TEST_UTIL_H */
--- upstart-1.5.orig/po/en@boldquot.po
+++ upstart-1.5/po/en@boldquot.po
@@ -32,7 +32,7 @@
 msgstr ""
 "Project-Id-Version: upstart 1.5\n"
 "Report-Msgid-Bugs-To: new@bugs.launchpad.net\n"
-"POT-Creation-Date: 2012-03-22 11:02+0000\n"
+"POT-Creation-Date: 2011-12-14 11:53+0000\n"
 "PO-Revision-Date: 2012-03-22 11:02+0000\n"
 "Last-Translator: Automatically generated\n"
 "Language-Team: none\n"
@@ -88,7 +88,7 @@
 msgid "Disconnected from system bus"
 msgstr "Disconnected from system bus"
 
-#: init/control.c:370 init/main.c:694
+#: init/control.c:370 init/main.c:830
 msgid "Reloading configuration"
 msgstr "Reloading configuration"
 
@@ -101,8 +101,8 @@
 msgid "Unknown job: %s"
 msgstr "Unknown job: %s"
 
-#: init/control.c:574 init/job_class.c:552 init/job_class.c:762
-#: init/job_class.c:902 init/job_class.c:1037
+#: init/control.c:574 init/job_class.c:550 init/job_class.c:749
+#: init/job_class.c:879 init/job_class.c:1014
 msgid "Env must be KEY=VALUE pairs"
 msgstr "Env must be KEY=VALUE pairs"
 
@@ -110,10 +110,6 @@
 msgid "The log priority given was not recognised"
 msgstr "The log priority given was not recognised"
 
-#: init/control.c:792
-msgid "You do not have permission to notify disk is writeable"
-msgstr "You do not have permission to notify disk is writeable"
-
 #: init/errors.h:60
 msgid "Illegal parameter"
 msgstr "Illegal parameter"
@@ -200,102 +196,98 @@
 msgid "Event failed"
 msgstr "Event failed"
 
-#: init/job.c:246
+#: init/job.c:235
 #, c-format
 msgid "%s goal changed from %s to %s"
 msgstr "%s goal changed from %s to %s"
 
-#: init/job.c:317
+#: init/job.c:306
 #, c-format
 msgid "%s state changed from %s to %s"
 msgstr "%s state changed from %s to %s"
 
-#: init/job.c:736 init/job.c:774
+#: init/job.c:725 init/job.c:763
 msgid "Job failed to start"
 msgstr "Job failed to start"
 
-#: init/job.c:749 init/job.c:785
+#: init/job.c:738 init/job.c:774
 msgid "Job failed while stopping"
 msgstr "Job failed while stopping"
 
-#: init/job.c:761 init/job.c:796
+#: init/job.c:750 init/job.c:785
 msgid "Job failed to restart"
 msgstr "Job failed to restart"
 
-#: init/job.c:990
+#: init/job.c:979
 msgid "stop"
 msgstr "stop"
 
-#: init/job.c:992
+#: init/job.c:981
 msgid "start"
 msgstr "start"
 
-#: init/job.c:994
+#: init/job.c:983
 msgid "respawn"
 msgstr "respawn"
 
-#: init/job.c:1039
+#: init/job.c:1028
 msgid "waiting"
 msgstr "waiting"
 
-#: init/job.c:1041
+#: init/job.c:1030
 msgid "starting"
 msgstr "starting"
 
-#: init/job.c:1043 init/process.c:80
+#: init/job.c:1032 init/process.c:80
 msgid "pre-start"
 msgstr "pre-start"
 
-#: init/job.c:1045
+#: init/job.c:1034
 msgid "spawned"
 msgstr "spawned"
 
-#: init/job.c:1047 init/process.c:82
+#: init/job.c:1036 init/process.c:82
 msgid "post-start"
 msgstr "post-start"
 
-#: init/job.c:1049
+#: init/job.c:1038
 msgid "running"
 msgstr "running"
 
-#: init/job.c:1051 init/process.c:84
+#: init/job.c:1040 init/process.c:84
 msgid "pre-stop"
 msgstr "pre-stop"
 
-#: init/job.c:1053
+#: init/job.c:1042
 msgid "stopping"
 msgstr "stopping"
 
-#: init/job.c:1055
+#: init/job.c:1044
 msgid "killed"
 msgstr "killed"
 
-#: init/job.c:1057 init/process.c:86
+#: init/job.c:1046 init/process.c:86
 msgid "post-stop"
 msgstr "post-stop"
 
-#: init/job.c:1140 init/job.c:1215 init/job.c:1291 init/job_class.c:754
-#: init/job_class.c:894 init/job_class.c:1029
+#: init/job.c:1129 init/job.c:1204 init/job.c:1280 init/job_class.c:741
+#: init/job_class.c:871 init/job_class.c:1006
 #, c-format
 msgid "You do not have permission to modify job: %s"
 msgstr "You do not have permission to modify job: %s"
 
-#: init/job.c:1148 init/job_class.c:818
+#: init/job.c:1137 init/job_class.c:795
 #, c-format
 msgid "Job is already running: %s"
 msgstr "Job is already running: %s"
 
-#: init/job.c:1223 init/job.c:1299 init/job_class.c:948 init/job_class.c:1082
+#: init/job.c:1212 init/job.c:1288 init/job_class.c:925 init/job_class.c:1059
 #, c-format
 msgid "Job has already been stopped: %s"
 msgstr "Job has already been stopped: %s"
 
-#: init/job_class.c:582 init/job_class.c:792 util/initctl.c:1383
-msgid "Usage"
-msgstr "Usage"
-
-#: init/job_class.c:600 init/job_class.c:645 init/job_class.c:940
-#: init/job_class.c:1074
+#: init/job_class.c:587 init/job_class.c:632 init/job_class.c:917
+#: init/job_class.c:1051
 #, c-format
 msgid "Unknown instance: %s"
 msgstr "Unknown instance: %s"
@@ -314,258 +306,254 @@
 msgid "%s %s process (%d)"
 msgstr "%s %s process (%d)"
 
-#: init/job_process.c:469
-msgid "Failed to create pty - disabling logging for job"
-msgstr "Failed to create pty - disabling logging for job"
+#: init/job_process.c:461
+msgid "No available ptys"
+msgstr "No available ptys"
 
-#: init/job_process.c:516
+#: init/job_process.c:491
 #, c-format
 msgid "Pausing %s (%d) [pre-exec] for debug"
 msgstr "Pausing %s (%d) [pre-exec] for debug"
 
-#: init/job_process.c:718
+#: init/job_process.c:686
 #, c-format
 msgid "Failed to open system console: %s"
 msgstr "Failed to open system console: %s"
 
-#: init/job_process.c:1026
+#: init/job_process.c:992
 #, c-format
 msgid "unable to move script fd: %s"
 msgstr "unable to move script fd: %s"
 
-#: init/job_process.c:1031
+#: init/job_process.c:997
 #, c-format
 msgid "unable to open console: %s"
 msgstr "unable to open console: %s"
 
-#: init/job_process.c:1086
+#: init/job_process.c:1052
 #, c-format
 msgid "unable to set \"%s\" resource limit: %s"
 msgstr "unable to set “[1m%s[0m” resource limit: %s"
 
-#: init/job_process.c:1091
+#: init/job_process.c:1057
 #, c-format
 msgid "unable to set priority: %s"
 msgstr "unable to set priority: %s"
 
-#: init/job_process.c:1096
+#: init/job_process.c:1062
 #, c-format
 msgid "unable to set oom adjustment: %s"
 msgstr "unable to set oom adjustment: %s"
 
-#: init/job_process.c:1101
+#: init/job_process.c:1067
 #, c-format
 msgid "unable to change root directory: %s"
 msgstr "unable to change root directory: %s"
 
-#: init/job_process.c:1106
+#: init/job_process.c:1072
 #, c-format
 msgid "unable to change working directory: %s"
 msgstr "unable to change working directory: %s"
 
-#: init/job_process.c:1111
+#: init/job_process.c:1077
 #, c-format
 msgid "unable to set trace: %s"
 msgstr "unable to set trace: %s"
 
-#: init/job_process.c:1116
+#: init/job_process.c:1082
 #, c-format
 msgid "unable to execute: %s"
 msgstr "unable to execute: %s"
 
-#: init/job_process.c:1121
+#: init/job_process.c:1087
 #, c-format
 msgid "unable to getpwnam: %s"
 msgstr "unable to getpwnam: %s"
 
-#: init/job_process.c:1126
+#: init/job_process.c:1092
 #, c-format
 msgid "unable to getgrnam: %s"
 msgstr "unable to getgrnam: %s"
 
-#: init/job_process.c:1131
+#: init/job_process.c:1097
 msgid "unable to find setuid user"
 msgstr "unable to find setuid user"
 
-#: init/job_process.c:1135
+#: init/job_process.c:1101
 msgid "unable to find setgid group"
 msgstr "unable to find setgid group"
 
-#: init/job_process.c:1139
+#: init/job_process.c:1105
 #, c-format
 msgid "unable to setuid: %s"
 msgstr "unable to setuid: %s"
 
-#: init/job_process.c:1144
+#: init/job_process.c:1110
 #, c-format
 msgid "unable to setgid: %s"
 msgstr "unable to setgid: %s"
 
-#: init/job_process.c:1149
+#: init/job_process.c:1115
 #, c-format
 msgid "unable to chown: %s"
 msgstr "unable to chown: %s"
 
-#: init/job_process.c:1154
+#: init/job_process.c:1120
 #, c-format
 msgid "unable to open pt master: %s"
 msgstr "unable to open pt master: %s"
 
-#: init/job_process.c:1159
+#: init/job_process.c:1125
 #, c-format
 msgid "unable to unlockpt: %s"
 msgstr "unable to unlockpt: %s"
 
-#: init/job_process.c:1164
+#: init/job_process.c:1130
 #, c-format
 msgid "unable to get ptsname: %s"
 msgstr "unable to get ptsname: %s"
 
-#: init/job_process.c:1169
+#: init/job_process.c:1135
 #, c-format
 msgid "unable to open pt slave: %s"
 msgstr "unable to open pt slave: %s"
 
-#: init/job_process.c:1200 init/job_process.c:1250
+#: init/job_process.c:1166 init/job_process.c:1216
 #, c-format
 msgid "Sending %s signal to %s %s process (%d)"
 msgstr "Sending %s signal to %s %s process (%d)"
 
-#: init/job_process.c:1209 init/job_process.c:1259
+#: init/job_process.c:1175 init/job_process.c:1225
 #, c-format
 msgid "Failed to send %s signal to %s %s process (%d): %s"
 msgstr "Failed to send %s signal to %s %s process (%d): %s"
 
-#: init/job_process.c:1320
+#: init/job_process.c:1286
 #, c-format
 msgid "%s %s process (%d) terminated with status %d"
 msgstr "%s %s process (%d) terminated with status %d"
 
-#: init/job_process.c:1325
+#: init/job_process.c:1291
 #, c-format
 msgid "%s %s process (%d) exited normally"
 msgstr "%s %s process (%d) exited normally"
 
-#: init/job_process.c:1340
+#: init/job_process.c:1306
 #, c-format
 msgid "%s %s process (%d) killed by %s signal"
 msgstr "%s %s process (%d) killed by %s signal"
 
-#: init/job_process.c:1344
+#: init/job_process.c:1310
 #, c-format
 msgid "%s %s process (%d) killed by signal %d"
 msgstr "%s %s process (%d) killed by signal %d"
 
-#: init/job_process.c:1358
+#: init/job_process.c:1324
 #, c-format
 msgid "%s %s process (%d) stopped by %s signal"
 msgstr "%s %s process (%d) stopped by %s signal"
 
-#: init/job_process.c:1362
+#: init/job_process.c:1328
 #, c-format
 msgid "%s %s process (%d) stopped by signal %d"
 msgstr "%s %s process (%d) stopped by signal %d"
 
-#: init/job_process.c:1376
+#: init/job_process.c:1342
 #, c-format
 msgid "%s %s process (%d) continued by %s signal"
 msgstr "%s %s process (%d) continued by %s signal"
 
-#: init/job_process.c:1380
+#: init/job_process.c:1346
 #, c-format
 msgid "%s %s process (%d) continued by signal %d"
 msgstr "%s %s process (%d) continued by signal %d"
 
-#: init/job_process.c:1515
+#: init/job_process.c:1481
 #, c-format
 msgid "%s respawning too fast, stopped"
 msgstr "%s respawning too fast, stopped"
 
-#: init/job_process.c:1521
+#: init/job_process.c:1487
 #, c-format
 msgid "%s %s process ended, respawning"
 msgstr "%s %s process ended, respawning"
 
-#: init/job_process.c:1621
-msgid "Failed to add log to unflushed queue"
-msgstr "Failed to add log to unflushed queue"
-
-#: init/job_process.c:1787
+#: init/job_process.c:1727
 #, c-format
 msgid "Failed to set ptrace options for %s %s process (%d): %s"
 msgstr "Failed to set ptrace options for %s %s process (%d): %s"
 
-#: init/job_process.c:1800 init/job_process.c:1995
+#: init/job_process.c:1740 init/job_process.c:1935
 #, c-format
 msgid "Failed to continue traced %s %s process (%d): %s"
 msgstr "Failed to continue traced %s %s process (%d): %s"
 
-#: init/job_process.c:1840 init/job_process.c:1931 init/job_process.c:1986
+#: init/job_process.c:1780 init/job_process.c:1871 init/job_process.c:1926
 #, c-format
 msgid "Failed to detach traced %s %s process (%d): %s"
 msgstr "Failed to detach traced %s %s process (%d): %s"
 
-#: init/job_process.c:1880
+#: init/job_process.c:1820
 #, c-format
 msgid "Failed to deliver signal to traced %s %s process (%d): %s"
 msgstr "Failed to deliver signal to traced %s %s process (%d): %s"
 
-#: init/job_process.c:1915
+#: init/job_process.c:1855
 #, c-format
 msgid "Failed to obtain child process id for %s %s process (%d): %s"
 msgstr "Failed to obtain child process id for %s %s process (%d): %s"
 
-#: init/job_process.c:1922
+#: init/job_process.c:1862
 #, c-format
 msgid "%s %s process (%d) became new process (%d)"
 msgstr "%s %s process (%d) became new process (%d)"
 
-#: init/job_process.c:1981
+#: init/job_process.c:1921
 #, c-format
 msgid "%s %s process (%d) executable changed"
 msgstr "%s %s process (%d) executable changed"
 
-#: init/log.c:350
+#: init/log.c:260
 msgid "Failed to write to log file"
 msgstr "Failed to write to log file"
 
-#: init/main.c:131
+#: init/main.c:135
 msgid "specify alternative directory to load configuration files from"
 msgstr "specify alternative directory to load configuration files from"
 
-#: init/main.c:134
+#: init/main.c:138
 msgid "default value for console stanza"
 msgstr "default value for console stanza"
 
-#: init/main.c:137
+#: init/main.c:141
 msgid "specify alternative directory to store job output logs in"
 msgstr "specify alternative directory to store job output logs in"
 
-#: init/main.c:140
+#: init/main.c:144
 msgid "disable job logging"
 msgstr "disable job logging"
 
-#: init/main.c:143
+#: init/main.c:147
 msgid "disable user and chroot sessions"
 msgstr "disable user and chroot sessions"
 
-#: init/main.c:146
+#: init/main.c:150
 msgid "do not emit any startup event (for testing)"
 msgstr "do not emit any startup event (for testing)"
 
-#: init/main.c:151
+#: init/main.c:155
 msgid "use D-Bus session bus rather than system bus (for testing)"
 msgstr "use D-Bus session bus rather than system bus (for testing)"
 
-#: init/main.c:154
+#: init/main.c:158
 msgid "specify an alternative initial event (for testing)"
 msgstr "specify an alternative initial event (for testing)"
 
-#: init/main.c:174
+#: init/main.c:178
 msgid "Process management daemon."
 msgstr "Process management daemon."
 
-#: init/main.c:176
+#: init/main.c:180
 msgid ""
 "This daemon is normally executed by the kernel and given process id 1 to "
 "denote its special status.  When executed by a user process, it will "
@@ -575,65 +563,75 @@
 "denote its special status.  When executed by a user process, it will "
 "actually run /sbin/telinit."
 
-#: init/main.c:197 util/reboot.c:166 util/shutdown.c:363 util/telinit.c:148
+#: init/main.c:201 util/reboot.c:166 util/shutdown.c:363 util/telinit.c:148
 msgid "Need to be root"
 msgstr "Need to be root"
 
-#: init/main.c:206
+#: init/main.c:210
 msgid "Not being executed as init"
 msgstr "Not being executed as init"
 
-#: init/main.c:247
+#: init/main.c:251
 msgid "Unable to initialize console, will try /dev/null"
 msgstr "Unable to initialize console, will try /dev/null"
 
-#: init/main.c:253
+#: init/main.c:257
 msgid "Unable to initialize console as /dev/null"
 msgstr "Unable to initialize console as /dev/null"
 
-#: init/main.c:269 init/main.c:604
+#: init/main.c:273 init/main.c:687
 msgid "Unable to set root directory"
 msgstr "Unable to set root directory"
 
-#: init/main.c:280
+#: init/main.c:284
 msgid "Unable to mount /proc filesystem"
 msgstr "Unable to mount /proc filesystem"
 
-#: init/main.c:289
+#: init/main.c:293
 msgid "Unable to mount /sys filesystem"
 msgstr "Unable to mount /sys filesystem"
 
-#: init/main.c:392 init/main.c:398
+#: init/main.c:403 init/main.c:409
 msgid "Unable to set default oom score"
 msgstr "Unable to set default oom score"
 
-#: init/main.c:417
+#: init/main.c:428
 msgid "Unable to listen for private connections"
 msgstr "Unable to listen for private connections"
 
-#: init/main.c:450
+#: init/main.c:461
 msgid "Unable to setup standard file descriptors"
 msgstr "Unable to setup standard file descriptors"
 
-#: init/main.c:621
+#: init/main.c:704
 #, c-format
 msgid "Caught %s, core dumped"
 msgstr "Caught %s, core dumped"
 
-#: init/main.c:625
+#: init/main.c:708
 #, c-format
 msgid "Caught %s, unable to dump core"
 msgstr "Caught %s, unable to dump core"
 
-#: init/main.c:711
+#: init/main.c:737
+#, c-format
+msgid "Re-executing %s"
+msgstr "Re-executing %s"
+
+#: init/main.c:762
+#, c-format
+msgid "Failed to re-execute %s: %s"
+msgstr "Failed to re-execute %s: %s"
+
+#: init/main.c:847
 msgid "Reconnecting to system bus"
 msgstr "Reconnecting to system bus"
 
-#: init/main.c:717
+#: init/main.c:853
 msgid "Unable to connect to the system bus"
 msgstr "Unable to connect to the system bus"
 
-#: init/main.c:793
+#: init/main.c:929
 msgid "invalid console type specified"
 msgstr "invalid console type specified"
 
@@ -645,79 +643,79 @@
 msgid "Unable to lookup home directory"
 msgstr "Unable to lookup home directory"
 
-#: util/initctl.c:309
+#: util/initctl.c:305
 msgid "Unable to connect to system bus"
 msgstr "Unable to connect to system bus"
 
-#: util/initctl.c:310
+#: util/initctl.c:306
 msgid "Unable to connect to session bus"
 msgstr "Unable to connect to session bus"
 
-#: util/initctl.c:319
+#: util/initctl.c:315
 #, c-format
 msgid "%s: --dest given without --system\n"
 msgstr "%s: --dest given without --system\n"
 
-#: util/initctl.c:327
+#: util/initctl.c:323
 msgid "Unable to connect to Upstart"
 msgstr "Unable to connect to Upstart"
 
-#: util/initctl.c:536 util/initctl.c:671 util/initctl.c:799 util/initctl.c:934
-#: util/initctl.c:1039 util/initctl.c:1353
+#: util/initctl.c:509 util/initctl.c:644 util/initctl.c:772 util/initctl.c:907
+#: util/initctl.c:1012
 #, c-format
 msgid "%s: missing job name\n"
 msgstr "%s: missing job name\n"
 
-#: util/initctl.c:985
+#: util/initctl.c:958
 msgid "Not running"
 msgstr "Not running"
 
-#: util/initctl.c:1418
+#: util/initctl.c:1314
 #, c-format
 msgid "%s: missing event name\n"
 msgstr "%s: missing event name\n"
 
-#: util/initctl.c:1615
+#: util/initctl.c:1511
 msgid "Invalid job class"
 msgstr "Invalid job class"
 
-#: util/initctl.c:2248
+#: util/initctl.c:2108
 msgid "unknown event"
 msgstr "unknown event"
 
-#: util/initctl.c:2252
+#: util/initctl.c:2112
 msgid "unknown job"
 msgstr "unknown job"
 
-#: util/initctl.c:2353
+#: util/initctl.c:2213
 msgid "use D-Bus session bus to connect to init daemon (for testing)"
 msgstr "use D-Bus session bus to connect to init daemon (for testing)"
 
-#: util/initctl.c:2355
+#: util/initctl.c:2215
 msgid "use D-Bus system bus to connect to init daemon"
 msgstr "use D-Bus system bus to connect to init daemon"
 
-#: util/initctl.c:2357
+#: util/initctl.c:2217
 msgid "destination well-known name on D-Bus bus"
 msgstr "destination well-known name on D-Bus bus"
 
-#: util/initctl.c:2370
+#: util/initctl.c:2230
 msgid "do not wait for job to start before exiting"
 msgstr "do not wait for job to start before exiting"
 
-#: util/initctl.c:2382
+#: util/initctl.c:2242
 msgid "do not wait for job to stop before exiting"
 msgstr "do not wait for job to stop before exiting"
 
-#: util/initctl.c:2394
+#: util/initctl.c:2254
 msgid "do not wait for job to restart before exiting"
 msgstr "do not wait for job to restart before exiting"
 
-#: util/initctl.c:2433
+#: util/initctl.c:2293
 msgid "do not wait for event to finish before exiting"
 msgstr "do not wait for event to finish before exiting"
 
-#: util/initctl.c:2474
+#: util/initctl.c:2334
 msgid ""
 "enumerate list of events and jobs causing job created from job config to "
 "start/stop"
@@ -725,32 +723,32 @@
 "enumerate list of events and jobs causing job created from job config to "
 "start/stop"
 
-#: util/initctl.c:2487
+#: util/initctl.c:2347
 msgid "ignore specified list of events (comma-separated)"
 msgstr "ignore specified list of events (comma-separated)"
 
-#: util/initctl.c:2489
+#: util/initctl.c:2349
 msgid "Generate warning for any unreachable events/jobs"
 msgstr "Generate warning for any unreachable events/jobs"
 
-#: util/initctl.c:2508
+#: util/initctl.c:2358
 msgid "Job"
 msgstr "Job"
 
-#: util/initctl.c:2515
+#: util/initctl.c:2365
 msgid "Event"
 msgstr "Event"
 
-#: util/initctl.c:2523 util/initctl.c:2535 util/initctl.c:2546
-#: util/initctl.c:2557 util/initctl.c:2564
+#: util/initctl.c:2373 util/initctl.c:2385 util/initctl.c:2396
+#: util/initctl.c:2407 util/initctl.c:2414
 msgid "JOB [KEY=VALUE]..."
 msgstr "JOB [KEY=VALUE]..."
 
-#: util/initctl.c:2524
+#: util/initctl.c:2374
 msgid "Start job."
 msgstr "Start job."
 
-#: util/initctl.c:2525
+#: util/initctl.c:2375
 msgid ""
 "JOB is the name of the job that is to be started, this may be followed by "
 "zero or more environment variables to be defined in the new job.\n"
@@ -766,11 +764,11 @@
 "thus decide whether a new instance will be started or an error returned if "
 "an existing instance is already running."
 
-#: util/initctl.c:2536
+#: util/initctl.c:2386
 msgid "Stop job."
 msgstr "Stop job."
 
-#: util/initctl.c:2537
+#: util/initctl.c:2387
 msgid ""
 "JOB is the name of the job that is to be stopped, this may be followed by "
 "zero or more environment variables to be passed to the job's pre-stop and "
@@ -786,11 +784,11 @@
 "The environment also serves to distinguish between job instances, and thus "
 "decide which of multiple instances will be stopped."
 
-#: util/initctl.c:2547
+#: util/initctl.c:2397
 msgid "Restart job."
 msgstr "Restart job."
 
-#: util/initctl.c:2548
+#: util/initctl.c:2398
 msgid ""
 "JOB is the name of the job that is to be restarted, this may be followed by "
 "zero or more environment variables to be defined in the job after "
@@ -806,11 +804,11 @@
 "The environment also serves to distinguish between job instances, and thus "
 "decide which of multiple instances will be restarted."
 
-#: util/initctl.c:2558
+#: util/initctl.c:2408
 msgid "Send HUP signal to job."
 msgstr "Send HUP signal to job."
 
-#: util/initctl.c:2559
+#: util/initctl.c:2409
 msgid ""
 "JOB is the name of the job that is to be sent the signal, this may be "
 "followed by zero or more environment variables to distinguish between job "
@@ -820,11 +818,11 @@
 "followed by zero or more environment variables to distinguish between job "
 "instances.\n"
 
-#: util/initctl.c:2565
+#: util/initctl.c:2415
 msgid "Query status of job."
 msgstr "Query status of job."
 
-#: util/initctl.c:2566
+#: util/initctl.c:2416
 msgid ""
 "JOB is the name of the job that is to be queried, this may be followed by "
 "zero or more environment variables to distguish between job instances.\n"
@@ -832,23 +830,23 @@
 "JOB is the name of the job that is to be queried, this may be followed by "
 "zero or more environment variables to distguish between job instances.\n"
 
-#: util/initctl.c:2572
+#: util/initctl.c:2422
 msgid "List known jobs."
 msgstr "List known jobs."
 
-#: util/initctl.c:2573
+#: util/initctl.c:2423
 msgid "The known jobs and their current status will be output."
 msgstr "The known jobs and their current status will be output."
 
-#: util/initctl.c:2576
+#: util/initctl.c:2426
 msgid "EVENT [KEY=VALUE]..."
 msgstr "EVENT [KEY=VALUE]..."
 
-#: util/initctl.c:2577
+#: util/initctl.c:2427
 msgid "Emit an event."
 msgstr "Emit an event."
 
-#: util/initctl.c:2578
+#: util/initctl.c:2428
 msgid ""
 "EVENT is the name of an event the init daemon should emit, this may be "
 "followed by zero or more environment variables to be included in the event.\n"
@@ -856,23 +854,23 @@
 "EVENT is the name of an event the init daemon should emit, this may be "
 "followed by zero or more environment variables to be included in the event.\n"
 
-#: util/initctl.c:2584
+#: util/initctl.c:2434
 msgid "Reload the configuration of the init daemon."
 msgstr "Reload the configuration of the init daemon."
 
-#: util/initctl.c:2588
+#: util/initctl.c:2438
 msgid "Request the version of the init daemon."
 msgstr "Request the version of the init daemon."
 
-#: util/initctl.c:2591
+#: util/initctl.c:2441
 msgid "[PRIORITY]"
 msgstr "[PRIORITY]"
 
-#: util/initctl.c:2592
+#: util/initctl.c:2442
 msgid "Change the minimum priority of log messages from the init daemon"
 msgstr "Change the minimum priority of log messages from the init daemon"
 
-#: util/initctl.c:2594
+#: util/initctl.c:2444
 msgid ""
 "PRIORITY may be one of:\n"
 "  `debug' (messages useful for debugging upstart are logged, equivalent to --"
@@ -902,15 +900,15 @@
 "\n"
 "Without arguments, this outputs the current log priority."
 
-#: util/initctl.c:2611 util/initctl.c:2617
+#: util/initctl.c:2461 util/initctl.c:2467
 msgid "[CONF]"
 msgstr "[CONF]"
 
-#: util/initctl.c:2612
+#: util/initctl.c:2462
 msgid "Show emits, start on and stop on details for job configurations."
 msgstr "Show emits, start on and stop on details for job configurations."
 
-#: util/initctl.c:2613
+#: util/initctl.c:2463
 msgid ""
 "If CONF specified, show configuration details for single job configuration, "
 "else show details for all jobs configurations.\n"
@@ -918,11 +916,11 @@
 "If CONF specified, show configuration details for single job configuration, "
 "else show details for all jobs configurations.\n"
 
-#: util/initctl.c:2618
+#: util/initctl.c:2468
 msgid "Check for unreachable jobs/event conditions."
 msgstr "Check for unreachable jobs/event conditions."
 
-#: util/initctl.c:2619
+#: util/initctl.c:2469
 msgid ""
 "List all jobs and events which cannot be satisfied by currently available "
 "job configuration files"
@@ -930,30 +928,6 @@
 "List all jobs and events which cannot be satisfied by currently available "
 "job configuration files"
 
-#: util/initctl.c:2623
-msgid "JOB"
-msgstr "JOB"
-
-#: util/initctl.c:2624
-msgid "Show job usage message if available."
-msgstr "Show job usage message if available."
-
-#: util/initctl.c:2625
-msgid "JOB is the name of the job which usage is to be shown.\n"
-msgstr "JOB is the name of the job which usage is to be shown.\n"
-
-#: util/initctl.c:2629
-msgid "Inform Upstart that disk is now writeable."
-msgstr "Inform Upstart that disk is now writeable."
-
-#: util/initctl.c:2630
-msgid ""
-"Run to ensure output from jobs ending before disk is writeable are flushed "
-"to disk"
-msgstr ""
-"Run to ensure output from jobs ending before disk is writeable are flushed "
-"to disk"
-
 #: util/reboot.c:113
 msgid "don't sync before reboot or halt"
 msgstr "don't sync before reboot or halt"
@@ -1250,7 +1224,7 @@
 msgid "Unable to become daemon"
 msgstr "Unable to become daemon"
 
-#: extra/upstart-udev-bridge.c:336 extra/upstart-socket-bridge.c:623
+#: extra/upstart-udev-bridge.c:333 extra/upstart-socket-bridge.c:623
 msgid "Disconnected from Upstart"
 msgstr "Disconnected from Upstart"
 
@@ -1293,3 +1267,34 @@
 #: extra/upstart-socket-bridge.c:642
 msgid "Error emitting socket event"
 msgstr "Error emitting socket event"
+
+#~ msgid "You do not have permission to notify disk is writeable"
+#~ msgstr "You do not have permission to notify disk is writeable"
+
+#~ msgid "Usage"
+#~ msgstr "Usage"
+
+#~ msgid "Failed to create pty - disabling logging for job"
+#~ msgstr "Failed to create pty - disabling logging for job"
+
+#~ msgid "Failed to add log to unflushed queue"
+#~ msgstr "Failed to add log to unflushed queue"
+
+#~ msgid "JOB"
+#~ msgstr "JOB"
+
+#~ msgid "Show job usage message if available."
+#~ msgstr "Show job usage message if available."
+
+#~ msgid "JOB is the name of the job which usage is to be shown.\n"
+#~ msgstr "JOB is the name of the job which usage is to be shown.\n"
+
+#~ msgid "Inform Upstart that disk is now writeable."
+#~ msgstr "Inform Upstart that disk is now writeable."
+
+#~ msgid ""
+#~ "Run to ensure output from jobs ending before disk is writeable are "
+#~ "flushed to disk"
+#~ msgstr ""
+#~ "Run to ensure output from jobs ending before disk is writeable are "
+#~ "flushed to disk"
--- upstart-1.5.orig/po/en@quot.po
+++ upstart-1.5/po/en@quot.po
@@ -29,7 +29,7 @@
 msgstr ""
 "Project-Id-Version: upstart 1.5\n"
 "Report-Msgid-Bugs-To: new@bugs.launchpad.net\n"
-"POT-Creation-Date: 2012-03-22 11:02+0000\n"
+"POT-Creation-Date: 2011-12-14 11:53+0000\n"
 "PO-Revision-Date: 2012-03-22 11:02+0000\n"
 "Last-Translator: Automatically generated\n"
 "Language-Team: none\n"
@@ -85,7 +85,7 @@
 msgid "Disconnected from system bus"
 msgstr "Disconnected from system bus"
 
-#: init/control.c:370 init/main.c:694
+#: init/control.c:370 init/main.c:830
 msgid "Reloading configuration"
 msgstr "Reloading configuration"
 
@@ -98,8 +98,8 @@
 msgid "Unknown job: %s"
 msgstr "Unknown job: %s"
 
-#: init/control.c:574 init/job_class.c:552 init/job_class.c:762
-#: init/job_class.c:902 init/job_class.c:1037
+#: init/control.c:574 init/job_class.c:550 init/job_class.c:749
+#: init/job_class.c:879 init/job_class.c:1014
 msgid "Env must be KEY=VALUE pairs"
 msgstr "Env must be KEY=VALUE pairs"
 
@@ -107,10 +107,6 @@
 msgid "The log priority given was not recognised"
 msgstr "The log priority given was not recognised"
 
-#: init/control.c:792
-msgid "You do not have permission to notify disk is writeable"
-msgstr "You do not have permission to notify disk is writeable"
-
 #: init/errors.h:60
 msgid "Illegal parameter"
 msgstr "Illegal parameter"
@@ -197,102 +193,98 @@
 msgid "Event failed"
 msgstr "Event failed"
 
-#: init/job.c:246
+#: init/job.c:235
 #, c-format
 msgid "%s goal changed from %s to %s"
 msgstr "%s goal changed from %s to %s"
 
-#: init/job.c:317
+#: init/job.c:306
 #, c-format
 msgid "%s state changed from %s to %s"
 msgstr "%s state changed from %s to %s"
 
-#: init/job.c:736 init/job.c:774
+#: init/job.c:725 init/job.c:763
 msgid "Job failed to start"
 msgstr "Job failed to start"
 
-#: init/job.c:749 init/job.c:785
+#: init/job.c:738 init/job.c:774
 msgid "Job failed while stopping"
 msgstr "Job failed while stopping"
 
-#: init/job.c:761 init/job.c:796
+#: init/job.c:750 init/job.c:785
 msgid "Job failed to restart"
 msgstr "Job failed to restart"
 
-#: init/job.c:990
+#: init/job.c:979
 msgid "stop"
 msgstr "stop"
 
-#: init/job.c:992
+#: init/job.c:981
 msgid "start"
 msgstr "start"
 
-#: init/job.c:994
+#: init/job.c:983
 msgid "respawn"
 msgstr "respawn"
 
-#: init/job.c:1039
+#: init/job.c:1028
 msgid "waiting"
 msgstr "waiting"
 
-#: init/job.c:1041
+#: init/job.c:1030
 msgid "starting"
 msgstr "starting"
 
-#: init/job.c:1043 init/process.c:80
+#: init/job.c:1032 init/process.c:80
 msgid "pre-start"
 msgstr "pre-start"
 
-#: init/job.c:1045
+#: init/job.c:1034
 msgid "spawned"
 msgstr "spawned"
 
-#: init/job.c:1047 init/process.c:82
+#: init/job.c:1036 init/process.c:82
 msgid "post-start"
 msgstr "post-start"
 
-#: init/job.c:1049
+#: init/job.c:1038
 msgid "running"
 msgstr "running"
 
-#: init/job.c:1051 init/process.c:84
+#: init/job.c:1040 init/process.c:84
 msgid "pre-stop"
 msgstr "pre-stop"
 
-#: init/job.c:1053
+#: init/job.c:1042
 msgid "stopping"
 msgstr "stopping"
 
-#: init/job.c:1055
+#: init/job.c:1044
 msgid "killed"
 msgstr "killed"
 
-#: init/job.c:1057 init/process.c:86
+#: init/job.c:1046 init/process.c:86
 msgid "post-stop"
 msgstr "post-stop"
 
-#: init/job.c:1140 init/job.c:1215 init/job.c:1291 init/job_class.c:754
-#: init/job_class.c:894 init/job_class.c:1029
+#: init/job.c:1129 init/job.c:1204 init/job.c:1280 init/job_class.c:741
+#: init/job_class.c:871 init/job_class.c:1006
 #, c-format
 msgid "You do not have permission to modify job: %s"
 msgstr "You do not have permission to modify job: %s"
 
-#: init/job.c:1148 init/job_class.c:818
+#: init/job.c:1137 init/job_class.c:795
 #, c-format
 msgid "Job is already running: %s"
 msgstr "Job is already running: %s"
 
-#: init/job.c:1223 init/job.c:1299 init/job_class.c:948 init/job_class.c:1082
+#: init/job.c:1212 init/job.c:1288 init/job_class.c:925 init/job_class.c:1059
 #, c-format
 msgid "Job has already been stopped: %s"
 msgstr "Job has already been stopped: %s"
 
-#: init/job_class.c:582 init/job_class.c:792 util/initctl.c:1383
-msgid "Usage"
-msgstr "Usage"
-
-#: init/job_class.c:600 init/job_class.c:645 init/job_class.c:940
-#: init/job_class.c:1074
+#: init/job_class.c:587 init/job_class.c:632 init/job_class.c:917
+#: init/job_class.c:1051
 #, c-format
 msgid "Unknown instance: %s"
 msgstr "Unknown instance: %s"
@@ -311,258 +303,254 @@
 msgid "%s %s process (%d)"
 msgstr "%s %s process (%d)"
 
-#: init/job_process.c:469
-msgid "Failed to create pty - disabling logging for job"
-msgstr "Failed to create pty - disabling logging for job"
+#: init/job_process.c:461
+msgid "No available ptys"
+msgstr "No available ptys"
 
-#: init/job_process.c:516
+#: init/job_process.c:491
 #, c-format
 msgid "Pausing %s (%d) [pre-exec] for debug"
 msgstr "Pausing %s (%d) [pre-exec] for debug"
 
-#: init/job_process.c:718
+#: init/job_process.c:686
 #, c-format
 msgid "Failed to open system console: %s"
 msgstr "Failed to open system console: %s"
 
-#: init/job_process.c:1026
+#: init/job_process.c:992
 #, c-format
 msgid "unable to move script fd: %s"
 msgstr "unable to move script fd: %s"
 
-#: init/job_process.c:1031
+#: init/job_process.c:997
 #, c-format
 msgid "unable to open console: %s"
 msgstr "unable to open console: %s"
 
-#: init/job_process.c:1086
+#: init/job_process.c:1052
 #, c-format
 msgid "unable to set \"%s\" resource limit: %s"
 msgstr "unable to set “%s” resource limit: %s"
 
-#: init/job_process.c:1091
+#: init/job_process.c:1057
 #, c-format
 msgid "unable to set priority: %s"
 msgstr "unable to set priority: %s"
 
-#: init/job_process.c:1096
+#: init/job_process.c:1062
 #, c-format
 msgid "unable to set oom adjustment: %s"
 msgstr "unable to set oom adjustment: %s"
 
-#: init/job_process.c:1101
+#: init/job_process.c:1067
 #, c-format
 msgid "unable to change root directory: %s"
 msgstr "unable to change root directory: %s"
 
-#: init/job_process.c:1106
+#: init/job_process.c:1072
 #, c-format
 msgid "unable to change working directory: %s"
 msgstr "unable to change working directory: %s"
 
-#: init/job_process.c:1111
+#: init/job_process.c:1077
 #, c-format
 msgid "unable to set trace: %s"
 msgstr "unable to set trace: %s"
 
-#: init/job_process.c:1116
+#: init/job_process.c:1082
 #, c-format
 msgid "unable to execute: %s"
 msgstr "unable to execute: %s"
 
-#: init/job_process.c:1121
+#: init/job_process.c:1087
 #, c-format
 msgid "unable to getpwnam: %s"
 msgstr "unable to getpwnam: %s"
 
-#: init/job_process.c:1126
+#: init/job_process.c:1092
 #, c-format
 msgid "unable to getgrnam: %s"
 msgstr "unable to getgrnam: %s"
 
-#: init/job_process.c:1131
+#: init/job_process.c:1097
 msgid "unable to find setuid user"
 msgstr "unable to find setuid user"
 
-#: init/job_process.c:1135
+#: init/job_process.c:1101
 msgid "unable to find setgid group"
 msgstr "unable to find setgid group"
 
-#: init/job_process.c:1139
+#: init/job_process.c:1105
 #, c-format
 msgid "unable to setuid: %s"
 msgstr "unable to setuid: %s"
 
-#: init/job_process.c:1144
+#: init/job_process.c:1110
 #, c-format
 msgid "unable to setgid: %s"
 msgstr "unable to setgid: %s"
 
-#: init/job_process.c:1149
+#: init/job_process.c:1115
 #, c-format
 msgid "unable to chown: %s"
 msgstr "unable to chown: %s"
 
-#: init/job_process.c:1154
+#: init/job_process.c:1120
 #, c-format
 msgid "unable to open pt master: %s"
 msgstr "unable to open pt master: %s"
 
-#: init/job_process.c:1159
+#: init/job_process.c:1125
 #, c-format
 msgid "unable to unlockpt: %s"
 msgstr "unable to unlockpt: %s"
 
-#: init/job_process.c:1164
+#: init/job_process.c:1130
 #, c-format
 msgid "unable to get ptsname: %s"
 msgstr "unable to get ptsname: %s"
 
-#: init/job_process.c:1169
+#: init/job_process.c:1135
 #, c-format
 msgid "unable to open pt slave: %s"
 msgstr "unable to open pt slave: %s"
 
-#: init/job_process.c:1200 init/job_process.c:1250
+#: init/job_process.c:1166 init/job_process.c:1216
 #, c-format
 msgid "Sending %s signal to %s %s process (%d)"
 msgstr "Sending %s signal to %s %s process (%d)"
 
-#: init/job_process.c:1209 init/job_process.c:1259
+#: init/job_process.c:1175 init/job_process.c:1225
 #, c-format
 msgid "Failed to send %s signal to %s %s process (%d): %s"
 msgstr "Failed to send %s signal to %s %s process (%d): %s"
 
-#: init/job_process.c:1320
+#: init/job_process.c:1286
 #, c-format
 msgid "%s %s process (%d) terminated with status %d"
 msgstr "%s %s process (%d) terminated with status %d"
 
-#: init/job_process.c:1325
+#: init/job_process.c:1291
 #, c-format
 msgid "%s %s process (%d) exited normally"
 msgstr "%s %s process (%d) exited normally"
 
-#: init/job_process.c:1340
+#: init/job_process.c:1306
 #, c-format
 msgid "%s %s process (%d) killed by %s signal"
 msgstr "%s %s process (%d) killed by %s signal"
 
-#: init/job_process.c:1344
+#: init/job_process.c:1310
 #, c-format
 msgid "%s %s process (%d) killed by signal %d"
 msgstr "%s %s process (%d) killed by signal %d"
 
-#: init/job_process.c:1358
+#: init/job_process.c:1324
 #, c-format
 msgid "%s %s process (%d) stopped by %s signal"
 msgstr "%s %s process (%d) stopped by %s signal"
 
-#: init/job_process.c:1362
+#: init/job_process.c:1328
 #, c-format
 msgid "%s %s process (%d) stopped by signal %d"
 msgstr "%s %s process (%d) stopped by signal %d"
 
-#: init/job_process.c:1376
+#: init/job_process.c:1342
 #, c-format
 msgid "%s %s process (%d) continued by %s signal"
 msgstr "%s %s process (%d) continued by %s signal"
 
-#: init/job_process.c:1380
+#: init/job_process.c:1346
 #, c-format
 msgid "%s %s process (%d) continued by signal %d"
 msgstr "%s %s process (%d) continued by signal %d"
 
-#: init/job_process.c:1515
+#: init/job_process.c:1481
 #, c-format
 msgid "%s respawning too fast, stopped"
 msgstr "%s respawning too fast, stopped"
 
-#: init/job_process.c:1521
+#: init/job_process.c:1487
 #, c-format
 msgid "%s %s process ended, respawning"
 msgstr "%s %s process ended, respawning"
 
-#: init/job_process.c:1621
-msgid "Failed to add log to unflushed queue"
-msgstr "Failed to add log to unflushed queue"
-
-#: init/job_process.c:1787
+#: init/job_process.c:1727
 #, c-format
 msgid "Failed to set ptrace options for %s %s process (%d): %s"
 msgstr "Failed to set ptrace options for %s %s process (%d): %s"
 
-#: init/job_process.c:1800 init/job_process.c:1995
+#: init/job_process.c:1740 init/job_process.c:1935
 #, c-format
 msgid "Failed to continue traced %s %s process (%d): %s"
 msgstr "Failed to continue traced %s %s process (%d): %s"
 
-#: init/job_process.c:1840 init/job_process.c:1931 init/job_process.c:1986
+#: init/job_process.c:1780 init/job_process.c:1871 init/job_process.c:1926
 #, c-format
 msgid "Failed to detach traced %s %s process (%d): %s"
 msgstr "Failed to detach traced %s %s process (%d): %s"
 
-#: init/job_process.c:1880
+#: init/job_process.c:1820
 #, c-format
 msgid "Failed to deliver signal to traced %s %s process (%d): %s"
 msgstr "Failed to deliver signal to traced %s %s process (%d): %s"
 
-#: init/job_process.c:1915
+#: init/job_process.c:1855
 #, c-format
 msgid "Failed to obtain child process id for %s %s process (%d): %s"
 msgstr "Failed to obtain child process id for %s %s process (%d): %s"
 
-#: init/job_process.c:1922
+#: init/job_process.c:1862
 #, c-format
 msgid "%s %s process (%d) became new process (%d)"
 msgstr "%s %s process (%d) became new process (%d)"
 
-#: init/job_process.c:1981
+#: init/job_process.c:1921
 #, c-format
 msgid "%s %s process (%d) executable changed"
 msgstr "%s %s process (%d) executable changed"
 
-#: init/log.c:350
+#: init/log.c:260
 msgid "Failed to write to log file"
 msgstr "Failed to write to log file"
 
-#: init/main.c:131
+#: init/main.c:135
 msgid "specify alternative directory to load configuration files from"
 msgstr "specify alternative directory to load configuration files from"
 
-#: init/main.c:134
+#: init/main.c:138
 msgid "default value for console stanza"
 msgstr "default value for console stanza"
 
-#: init/main.c:137
+#: init/main.c:141
 msgid "specify alternative directory to store job output logs in"
 msgstr "specify alternative directory to store job output logs in"
 
-#: init/main.c:140
+#: init/main.c:144
 msgid "disable job logging"
 msgstr "disable job logging"
 
-#: init/main.c:143
+#: init/main.c:147
 msgid "disable user and chroot sessions"
 msgstr "disable user and chroot sessions"
 
-#: init/main.c:146
+#: init/main.c:150
 msgid "do not emit any startup event (for testing)"
 msgstr "do not emit any startup event (for testing)"
 
-#: init/main.c:151
+#: init/main.c:155
 msgid "use D-Bus session bus rather than system bus (for testing)"
 msgstr "use D-Bus session bus rather than system bus (for testing)"
 
-#: init/main.c:154
+#: init/main.c:158
 msgid "specify an alternative initial event (for testing)"
 msgstr "specify an alternative initial event (for testing)"
 
-#: init/main.c:174
+#: init/main.c:178
 msgid "Process management daemon."
 msgstr "Process management daemon."
 
-#: init/main.c:176
+#: init/main.c:180
 msgid ""
 "This daemon is normally executed by the kernel and given process id 1 to "
 "denote its special status.  When executed by a user process, it will "
@@ -572,65 +560,75 @@
 "denote its special status.  When executed by a user process, it will "
 "actually run /sbin/telinit."
 
-#: init/main.c:197 util/reboot.c:166 util/shutdown.c:363 util/telinit.c:148
+#: init/main.c:201 util/reboot.c:166 util/shutdown.c:363 util/telinit.c:148
 msgid "Need to be root"
 msgstr "Need to be root"
 
-#: init/main.c:206
+#: init/main.c:210
 msgid "Not being executed as init"
 msgstr "Not being executed as init"
 
-#: init/main.c:247
+#: init/main.c:251
 msgid "Unable to initialize console, will try /dev/null"
 msgstr "Unable to initialize console, will try /dev/null"
 
-#: init/main.c:253
+#: init/main.c:257
 msgid "Unable to initialize console as /dev/null"
 msgstr "Unable to initialize console as /dev/null"
 
-#: init/main.c:269 init/main.c:604
+#: init/main.c:273 init/main.c:687
 msgid "Unable to set root directory"
 msgstr "Unable to set root directory"
 
-#: init/main.c:280
+#: init/main.c:284
 msgid "Unable to mount /proc filesystem"
 msgstr "Unable to mount /proc filesystem"
 
-#: init/main.c:289
+#: init/main.c:293
 msgid "Unable to mount /sys filesystem"
 msgstr "Unable to mount /sys filesystem"
 
-#: init/main.c:392 init/main.c:398
+#: init/main.c:403 init/main.c:409
 msgid "Unable to set default oom score"
 msgstr "Unable to set default oom score"
 
-#: init/main.c:417
+#: init/main.c:428
 msgid "Unable to listen for private connections"
 msgstr "Unable to listen for private connections"
 
-#: init/main.c:450
+#: init/main.c:461
 msgid "Unable to setup standard file descriptors"
 msgstr "Unable to setup standard file descriptors"
 
-#: init/main.c:621
+#: init/main.c:704
 #, c-format
 msgid "Caught %s, core dumped"
 msgstr "Caught %s, core dumped"
 
-#: init/main.c:625
+#: init/main.c:708
 #, c-format
 msgid "Caught %s, unable to dump core"
 msgstr "Caught %s, unable to dump core"
 
-#: init/main.c:711
+#: init/main.c:737
+#, c-format
+msgid "Re-executing %s"
+msgstr "Re-executing %s"
+
+#: init/main.c:762
+#, c-format
+msgid "Failed to re-execute %s: %s"
+msgstr "Failed to re-execute %s: %s"
+
+#: init/main.c:847
 msgid "Reconnecting to system bus"
 msgstr "Reconnecting to system bus"
 
-#: init/main.c:717
+#: init/main.c:853
 msgid "Unable to connect to the system bus"
 msgstr "Unable to connect to the system bus"
 
-#: init/main.c:793
+#: init/main.c:929
 msgid "invalid console type specified"
 msgstr "invalid console type specified"
 
@@ -642,79 +640,79 @@
 msgid "Unable to lookup home directory"
 msgstr "Unable to lookup home directory"
 
-#: util/initctl.c:309
+#: util/initctl.c:305
 msgid "Unable to connect to system bus"
 msgstr "Unable to connect to system bus"
 
-#: util/initctl.c:310
+#: util/initctl.c:306
 msgid "Unable to connect to session bus"
 msgstr "Unable to connect to session bus"
 
-#: util/initctl.c:319
+#: util/initctl.c:315
 #, c-format
 msgid "%s: --dest given without --system\n"
 msgstr "%s: --dest given without --system\n"
 
-#: util/initctl.c:327
+#: util/initctl.c:323
 msgid "Unable to connect to Upstart"
 msgstr "Unable to connect to Upstart"
 
-#: util/initctl.c:536 util/initctl.c:671 util/initctl.c:799 util/initctl.c:934
-#: util/initctl.c:1039 util/initctl.c:1353
+#: util/initctl.c:509 util/initctl.c:644 util/initctl.c:772 util/initctl.c:907
+#: util/initctl.c:1012
 #, c-format
 msgid "%s: missing job name\n"
 msgstr "%s: missing job name\n"
 
-#: util/initctl.c:985
+#: util/initctl.c:958
 msgid "Not running"
 msgstr "Not running"
 
-#: util/initctl.c:1418
+#: util/initctl.c:1314
 #, c-format
 msgid "%s: missing event name\n"
 msgstr "%s: missing event name\n"
 
-#: util/initctl.c:1615
+#: util/initctl.c:1511
 msgid "Invalid job class"
 msgstr "Invalid job class"
 
-#: util/initctl.c:2248
+#: util/initctl.c:2108
 msgid "unknown event"
 msgstr "unknown event"
 
-#: util/initctl.c:2252
+#: util/initctl.c:2112
 msgid "unknown job"
 msgstr "unknown job"
 
-#: util/initctl.c:2353
+#: util/initctl.c:2213
 msgid "use D-Bus session bus to connect to init daemon (for testing)"
 msgstr "use D-Bus session bus to connect to init daemon (for testing)"
 
-#: util/initctl.c:2355
+#: util/initctl.c:2215
 msgid "use D-Bus system bus to connect to init daemon"
 msgstr "use D-Bus system bus to connect to init daemon"
 
-#: util/initctl.c:2357
+#: util/initctl.c:2217
 msgid "destination well-known name on D-Bus bus"
 msgstr "destination well-known name on D-Bus bus"
 
-#: util/initctl.c:2370
+#: util/initctl.c:2230
 msgid "do not wait for job to start before exiting"
 msgstr "do not wait for job to start before exiting"
 
-#: util/initctl.c:2382
+#: util/initctl.c:2242
 msgid "do not wait for job to stop before exiting"
 msgstr "do not wait for job to stop before exiting"
 
-#: util/initctl.c:2394
+#: util/initctl.c:2254
 msgid "do not wait for job to restart before exiting"
 msgstr "do not wait for job to restart before exiting"
 
-#: util/initctl.c:2433
+#: util/initctl.c:2293
 msgid "do not wait for event to finish before exiting"
 msgstr "do not wait for event to finish before exiting"
 
-#: util/initctl.c:2474
+#: util/initctl.c:2334
 msgid ""
 "enumerate list of events and jobs causing job created from job config to "
 "start/stop"
@@ -722,32 +720,32 @@
 "enumerate list of events and jobs causing job created from job config to "
 "start/stop"
 
-#: util/initctl.c:2487
+#: util/initctl.c:2347
 msgid "ignore specified list of events (comma-separated)"
 msgstr "ignore specified list of events (comma-separated)"
 
-#: util/initctl.c:2489
+#: util/initctl.c:2349
 msgid "Generate warning for any unreachable events/jobs"
 msgstr "Generate warning for any unreachable events/jobs"
 
-#: util/initctl.c:2508
+#: util/initctl.c:2358
 msgid "Job"
 msgstr "Job"
 
-#: util/initctl.c:2515
+#: util/initctl.c:2365
 msgid "Event"
 msgstr "Event"
 
-#: util/initctl.c:2523 util/initctl.c:2535 util/initctl.c:2546
-#: util/initctl.c:2557 util/initctl.c:2564
+#: util/initctl.c:2373 util/initctl.c:2385 util/initctl.c:2396
+#: util/initctl.c:2407 util/initctl.c:2414
 msgid "JOB [KEY=VALUE]..."
 msgstr "JOB [KEY=VALUE]..."
 
-#: util/initctl.c:2524
+#: util/initctl.c:2374
 msgid "Start job."
 msgstr "Start job."
 
-#: util/initctl.c:2525
+#: util/initctl.c:2375
 msgid ""
 "JOB is the name of the job that is to be started, this may be followed by "
 "zero or more environment variables to be defined in the new job.\n"
@@ -763,11 +761,11 @@
 "thus decide whether a new instance will be started or an error returned if "
 "an existing instance is already running."
 
-#: util/initctl.c:2536
+#: util/initctl.c:2386
 msgid "Stop job."
 msgstr "Stop job."
 
-#: util/initctl.c:2537
+#: util/initctl.c:2387
 msgid ""
 "JOB is the name of the job that is to be stopped, this may be followed by "
 "zero or more environment variables to be passed to the job's pre-stop and "
@@ -783,11 +781,11 @@
 "The environment also serves to distinguish between job instances, and thus "
 "decide which of multiple instances will be stopped."
 
-#: util/initctl.c:2547
+#: util/initctl.c:2397
 msgid "Restart job."
 msgstr "Restart job."
 
-#: util/initctl.c:2548
+#: util/initctl.c:2398
 msgid ""
 "JOB is the name of the job that is to be restarted, this may be followed by "
 "zero or more environment variables to be defined in the job after "
@@ -803,11 +801,11 @@
 "The environment also serves to distinguish between job instances, and thus "
 "decide which of multiple instances will be restarted."
 
-#: util/initctl.c:2558
+#: util/initctl.c:2408
 msgid "Send HUP signal to job."
 msgstr "Send HUP signal to job."
 
-#: util/initctl.c:2559
+#: util/initctl.c:2409
 msgid ""
 "JOB is the name of the job that is to be sent the signal, this may be "
 "followed by zero or more environment variables to distinguish between job "
@@ -817,11 +815,11 @@
 "followed by zero or more environment variables to distinguish between job "
 "instances.\n"
 
-#: util/initctl.c:2565
+#: util/initctl.c:2415
 msgid "Query status of job."
 msgstr "Query status of job."
 
-#: util/initctl.c:2566
+#: util/initctl.c:2416
 msgid ""
 "JOB is the name of the job that is to be queried, this may be followed by "
 "zero or more environment variables to distguish between job instances.\n"
@@ -829,23 +827,23 @@
 "JOB is the name of the job that is to be queried, this may be followed by "
 "zero or more environment variables to distguish between job instances.\n"
 
-#: util/initctl.c:2572
+#: util/initctl.c:2422
 msgid "List known jobs."
 msgstr "List known jobs."
 
-#: util/initctl.c:2573
+#: util/initctl.c:2423
 msgid "The known jobs and their current status will be output."
 msgstr "The known jobs and their current status will be output."
 
-#: util/initctl.c:2576
+#: util/initctl.c:2426
 msgid "EVENT [KEY=VALUE]..."
 msgstr "EVENT [KEY=VALUE]..."
 
-#: util/initctl.c:2577
+#: util/initctl.c:2427
 msgid "Emit an event."
 msgstr "Emit an event."
 
-#: util/initctl.c:2578
+#: util/initctl.c:2428
 msgid ""
 "EVENT is the name of an event the init daemon should emit, this may be "
 "followed by zero or more environment variables to be included in the event.\n"
@@ -853,23 +851,23 @@
 "EVENT is the name of an event the init daemon should emit, this may be "
 "followed by zero or more environment variables to be included in the event.\n"
 
-#: util/initctl.c:2584
+#: util/initctl.c:2434
 msgid "Reload the configuration of the init daemon."
 msgstr "Reload the configuration of the init daemon."
 
-#: util/initctl.c:2588
+#: util/initctl.c:2438
 msgid "Request the version of the init daemon."
 msgstr "Request the version of the init daemon."
 
-#: util/initctl.c:2591
+#: util/initctl.c:2441
 msgid "[PRIORITY]"
 msgstr "[PRIORITY]"
 
-#: util/initctl.c:2592
+#: util/initctl.c:2442
 msgid "Change the minimum priority of log messages from the init daemon"
 msgstr "Change the minimum priority of log messages from the init daemon"
 
-#: util/initctl.c:2594
+#: util/initctl.c:2444
 msgid ""
 "PRIORITY may be one of:\n"
 "  `debug' (messages useful for debugging upstart are logged, equivalent to --"
@@ -899,15 +897,15 @@
 "\n"
 "Without arguments, this outputs the current log priority."
 
-#: util/initctl.c:2611 util/initctl.c:2617
+#: util/initctl.c:2461 util/initctl.c:2467
 msgid "[CONF]"
 msgstr "[CONF]"
 
-#: util/initctl.c:2612
+#: util/initctl.c:2462
 msgid "Show emits, start on and stop on details for job configurations."
 msgstr "Show emits, start on and stop on details for job configurations."
 
-#: util/initctl.c:2613
+#: util/initctl.c:2463
 msgid ""
 "If CONF specified, show configuration details for single job configuration, "
 "else show details for all jobs configurations.\n"
@@ -915,11 +913,11 @@
 "If CONF specified, show configuration details for single job configuration, "
 "else show details for all jobs configurations.\n"
 
-#: util/initctl.c:2618
+#: util/initctl.c:2468
 msgid "Check for unreachable jobs/event conditions."
 msgstr "Check for unreachable jobs/event conditions."
 
-#: util/initctl.c:2619
+#: util/initctl.c:2469
 msgid ""
 "List all jobs and events which cannot be satisfied by currently available "
 "job configuration files"
@@ -927,30 +925,6 @@
 "List all jobs and events which cannot be satisfied by currently available "
 "job configuration files"
 
-#: util/initctl.c:2623
-msgid "JOB"
-msgstr "JOB"
-
-#: util/initctl.c:2624
-msgid "Show job usage message if available."
-msgstr "Show job usage message if available."
-
-#: util/initctl.c:2625
-msgid "JOB is the name of the job which usage is to be shown.\n"
-msgstr "JOB is the name of the job which usage is to be shown.\n"
-
-#: util/initctl.c:2629
-msgid "Inform Upstart that disk is now writeable."
-msgstr "Inform Upstart that disk is now writeable."
-
-#: util/initctl.c:2630
-msgid ""
-"Run to ensure output from jobs ending before disk is writeable are flushed "
-"to disk"
-msgstr ""
-"Run to ensure output from jobs ending before disk is writeable are flushed "
-"to disk"
-
 #: util/reboot.c:113
 msgid "don't sync before reboot or halt"
 msgstr "don't sync before reboot or halt"
@@ -1247,7 +1221,7 @@
 msgid "Unable to become daemon"
 msgstr "Unable to become daemon"
 
-#: extra/upstart-udev-bridge.c:336 extra/upstart-socket-bridge.c:623
+#: extra/upstart-udev-bridge.c:333 extra/upstart-socket-bridge.c:623
 msgid "Disconnected from Upstart"
 msgstr "Disconnected from Upstart"
 
@@ -1290,3 +1264,34 @@
 #: extra/upstart-socket-bridge.c:642
 msgid "Error emitting socket event"
 msgstr "Error emitting socket event"
+
+#~ msgid "You do not have permission to notify disk is writeable"
+#~ msgstr "You do not have permission to notify disk is writeable"
+
+#~ msgid "Usage"
+#~ msgstr "Usage"
+
+#~ msgid "Failed to create pty - disabling logging for job"
+#~ msgstr "Failed to create pty - disabling logging for job"
+
+#~ msgid "Failed to add log to unflushed queue"
+#~ msgstr "Failed to add log to unflushed queue"
+
+#~ msgid "JOB"
+#~ msgstr "JOB"
+
+#~ msgid "Show job usage message if available."
+#~ msgstr "Show job usage message if available."
+
+#~ msgid "JOB is the name of the job which usage is to be shown.\n"
+#~ msgstr "JOB is the name of the job which usage is to be shown.\n"
+
+#~ msgid "Inform Upstart that disk is now writeable."
+#~ msgstr "Inform Upstart that disk is now writeable."
+
+#~ msgid ""
+#~ "Run to ensure output from jobs ending before disk is writeable are "
+#~ "flushed to disk"
+#~ msgstr ""
+#~ "Run to ensure output from jobs ending before disk is writeable are "
+#~ "flushed to disk"
--- upstart-1.5.orig/po/upstart.pot
+++ upstart-1.5/po/upstart.pot
@@ -8,7 +8,7 @@
 msgstr ""
 "Project-Id-Version: upstart 1.5\n"
 "Report-Msgid-Bugs-To: new@bugs.launchpad.net\n"
-"POT-Creation-Date: 2012-03-22 11:02+0000\n"
+"POT-Creation-Date: 2012-03-22 14:37+0000\n"
 "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
 "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
@@ -63,7 +63,7 @@
 msgid "Disconnected from system bus"
 msgstr ""
 
-#: init/control.c:370 init/main.c:694
+#: init/control.c:370 init/main.c:830
 msgid "Reloading configuration"
 msgstr ""
 
@@ -504,108 +504,118 @@
 msgid "Failed to write to log file"
 msgstr ""
 
-#: init/main.c:131
+#: init/main.c:135
 msgid "specify alternative directory to load configuration files from"
 msgstr ""
 
-#: init/main.c:134
+#: init/main.c:138
 msgid "default value for console stanza"
 msgstr ""
 
-#: init/main.c:137
+#: init/main.c:141
 msgid "specify alternative directory to store job output logs in"
 msgstr ""
 
-#: init/main.c:140
+#: init/main.c:144
 msgid "disable job logging"
 msgstr ""
 
-#: init/main.c:143
+#: init/main.c:147
 msgid "disable user and chroot sessions"
 msgstr ""
 
-#: init/main.c:146
+#: init/main.c:150
 msgid "do not emit any startup event (for testing)"
 msgstr ""
 
-#: init/main.c:151
+#: init/main.c:155
 msgid "use D-Bus session bus rather than system bus (for testing)"
 msgstr ""
 
-#: init/main.c:154
+#: init/main.c:158
 msgid "specify an alternative initial event (for testing)"
 msgstr ""
 
-#: init/main.c:174
+#: init/main.c:178
 msgid "Process management daemon."
 msgstr ""
 
-#: init/main.c:176
+#: init/main.c:180
 msgid ""
 "This daemon is normally executed by the kernel and given process id 1 to "
 "denote its special status.  When executed by a user process, it will "
 "actually run /sbin/telinit."
 msgstr ""
 
-#: init/main.c:197 util/reboot.c:166 util/shutdown.c:363 util/telinit.c:148
+#: init/main.c:201 util/reboot.c:166 util/shutdown.c:363 util/telinit.c:148
 msgid "Need to be root"
 msgstr ""
 
-#: init/main.c:206
+#: init/main.c:210
 msgid "Not being executed as init"
 msgstr ""
 
-#: init/main.c:247
+#: init/main.c:251
 msgid "Unable to initialize console, will try /dev/null"
 msgstr ""
 
-#: init/main.c:253
+#: init/main.c:257
 msgid "Unable to initialize console as /dev/null"
 msgstr ""
 
-#: init/main.c:269 init/main.c:604
+#: init/main.c:273 init/main.c:687
 msgid "Unable to set root directory"
 msgstr ""
 
-#: init/main.c:280
+#: init/main.c:284
 msgid "Unable to mount /proc filesystem"
 msgstr ""
 
-#: init/main.c:289
+#: init/main.c:293
 msgid "Unable to mount /sys filesystem"
 msgstr ""
 
-#: init/main.c:392 init/main.c:398
+#: init/main.c:403 init/main.c:409
 msgid "Unable to set default oom score"
 msgstr ""
 
-#: init/main.c:417
+#: init/main.c:428
 msgid "Unable to listen for private connections"
 msgstr ""
 
-#: init/main.c:450
+#: init/main.c:461
 msgid "Unable to setup standard file descriptors"
 msgstr ""
 
-#: init/main.c:621
+#: init/main.c:704
 #, c-format
 msgid "Caught %s, core dumped"
 msgstr ""
 
-#: init/main.c:625
+#: init/main.c:708
 #, c-format
 msgid "Caught %s, unable to dump core"
 msgstr ""
 
-#: init/main.c:711
+#: init/main.c:737
+#, c-format
+msgid "Re-executing %s"
+msgstr ""
+
+#: init/main.c:762
+#, c-format
+msgid "Failed to re-execute %s: %s"
+msgstr ""
+
+#: init/main.c:847
 msgid "Reconnecting to system bus"
 msgstr ""
 
-#: init/main.c:717
+#: init/main.c:853
 msgid "Unable to connect to the system bus"
 msgstr ""
 
-#: init/main.c:793
+#: init/main.c:929
 msgid "invalid console type specified"
 msgstr ""
 
--- upstart-1.5.orig/util/man/initctl.8
+++ upstart-1.5/util/man/initctl.8
@@ -16,6 +16,12 @@
 .BR init (8)
 daemon.
 
+If D\-Bus has been configured to allow non\-privileged users to invoke all
+Upstart D\-Bus methods, this command is also able to manage user jobs.
+See
+.BR init (5)
+for further details.
+
 When run as
 .BR initctl ,
 the first non\-option argument is the
--- upstart-1.5.orig/util/tests/test_user_sessions.sh
+++ upstart-1.5/util/tests/test_user_sessions.sh
@@ -0,0 +1,1091 @@
+#!/bin/sh
+#---------------------------------------------------------------------
+# Script to run minimal Upstart user session tests.
+#
+# Note that this script _cannot_ be run as part of the "make check"
+# tests since those tests stimulate functions and features of the
+# as-yet-uninstalled version of Upstart. However, this script needs to
+# run on a system where the version of Upstart under test has _already_
+# been fully installed.
+#---------------------------------------------------------------------
+#
+# Copyright (C) 2011 Canonical Ltd.
+#
+# Author: James Hunt <james.hunt@canonical.com>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, version 3 of the License.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+#---------------------------------------------------------------------
+
+script_name=${0##*/}
+sys_job_dir="/etc/init"
+user_job_dir="$HOME/.init"
+user_log_dir="$HOME/.cache/upstart/log"
+sys_log_dir="/var/log/upstart"
+bug_url="https://bugs.launchpad.net/upstart/+filebug"
+test_dir=
+test_dir_suffix=
+user_to_create=
+uid=
+gid=
+opt=
+OPTARG=
+debug_enabled=0
+feature=
+
+# allow non-priv users to find 'initctl'
+export PATH=$PATH:/sbin
+
+# for assertions
+die()
+{
+  msg="$*"
+  echo "ERROR: $msg" >&2
+  exit 1
+}
+
+debug()
+{
+  str="$1"
+  [ "$debug_enabled" = 1 ] && echo "DEBUG: $str"
+}
+
+get_job_pid()
+{
+  job="$1"
+  [ -z "$job" ] && die "need job"
+
+  pid=$(initctl status "$job"|grep process|awk '{print $NF}')
+  [ -z "$pid" ] && die "job $job has no pid"
+
+  echo "$pid"
+}
+
+# take a string and convert it into a valid job name
+make_job_name()
+{
+  str="$1"
+
+  echo "$str" |\
+    sed -e 's/>/ gt /g' -e 's/</ lt /g' -e 's/+/ and /g' |\
+    sed -e 's/[[:punct:]]//g' -e 's/  */ /g' |\
+    tr ' ' '-'
+}
+
+upstart_encode()
+{
+  str="$1"
+
+  echo "$str" | sed 's!/!_!g'
+}
+
+# take a string and convert it into a valid job log file name
+make_log_name()
+{
+  str="$1"
+  upstart_encode "$str"
+}
+
+TEST_FAILED()
+{
+  args="$*"
+
+  [ -z "$args" ] && die "need args"
+
+  echo
+  echo "ERROR: TEST FAILED ('$feature')"
+  echo
+  printf "BAD: ${args}\n"
+  printf "\nPlease report a bug at $bug_url including the following details:\n"
+  printf "\nUpstart:\n"
+  /sbin/init --version|head -n1
+  /sbin/initctl --version|head -n1
+  echo
+  printf "cmdline:\n"
+  cat /proc/cmdline
+  echo
+  printf "Upstart Env:\n"
+  set|grep UPSTART_
+  echo
+  printf "lsb:\n"
+  lsb_release -a
+  printf "\nuname:\n"
+  uname -a
+  echo
+  sync
+  echo "ERROR: TEST FAILED ('$feature')"
+  echo
+  exit 1
+}
+
+TEST_GROUP()
+{
+  name="$1"
+
+  [ -z "$name" ] && die "need name"
+
+  printf "Testing %s\n" "$name"
+}
+
+TEST_FEATURE()
+{
+  feature="$1"
+
+  [ -z "$feature" ] && die "need feature"
+
+  printf "...%s\n" "$feature"
+}
+
+TEST_NE()
+{
+  cmd="$1"
+  value="$2"
+  expected="$3"
+
+  # XXX: no checks on value or expected since they might be blank
+  [ -z "$cmd" ] && die "need cmd"
+
+  [ "$value" = "$expected" ] && TEST_FAILED \
+  "wrong value for '$cmd', expected $expected got $value"
+}
+
+TEST_EQ()
+{
+  cmd="$1"
+  value="$2"
+  expected="$3"
+
+  # XXX: no checks on value or expected since they might be blank
+  [ -z "$cmd" ] && die "need cmd"
+
+  [ "$value" != "$expected" ] && TEST_FAILED \
+  "wrong value for '$cmd', expected '$expected' got '$value'"
+}
+
+checks()
+{
+  cmd=initctl
+  [ -z "$(command -v $cmd)" ] && die "cannot find command $cmd"
+
+  [ "$(id -u)" = 0 ] && die "ERROR: should not run this function as root"
+
+  # This will fail for a non-root user unless D-Bus is correctly
+  # configured
+  $cmd emit foo || die \
+    "You do not appear to have configured D-Bus for Upstart user sessions. See usage."
+}
+
+setup()
+{
+  uid=$(id -u)
+  gid=$(id -g)
+
+  if [ "$uid" = 0 ]
+  then
+    [ -z "$user_to_create" ] && die "need '-u' option when running as root"
+
+    getent passwd "$user_to_create" && \
+      die "user '$user_to_create' already exists"
+
+    echo "Creating user '$user_to_create'"
+    cmd="useradd -mU -c 'Upstart Test User' $user_to_create"
+    eval "$cmd"
+    TEST_EQ "$cmd" $? 0
+
+    echo "Locking account for user '$user_to_create'"
+    cmd="usermod -L $user_to_create"
+    eval "$cmd"
+    TEST_EQ "$cmd" $? 0
+
+    # Run ourselves again as the new user
+    su -c "$0 -a" "$user_to_create"
+    test_run_rc=$?
+
+    if [ $test_run_rc -eq 0 ]
+    then
+      echo "Deleting user '$user_to_create'"
+      cmd="userdel -r \"$user_to_create\""
+      eval "$cmd"
+      TEST_EQ "$cmd" $? 0
+    fi
+
+    exit $test_run_rc
+  fi
+
+  checks
+
+  # setup
+  if [ ! -d "$user_job_dir" ]
+  then
+    cmd="mkdir -p \"$user_job_dir\""
+    eval $cmd
+    TEST_EQ "$cmd" $? 0
+
+    cmd="chmod 755 \"$user_job_dir\""
+    eval "$cmd"
+    TEST_EQ "$cmd" $? 0
+  fi
+
+  # create somewhere to store user jobs
+  cmd="mktemp -d --tmpdir=\"$user_job_dir\""
+  test_dir=$(eval "$cmd")
+  TEST_EQ "$cmd" $? 0
+  TEST_NE "$test_dir" "$test_dir" ""
+  test_dir_suffix=${test_dir#${user_job_dir}/}
+
+  # ensure files in this directory are accessible since
+  # mktemp sets directory perms to 0700 regardless of umask.
+  cmd="chmod 755 \"$test_dir\""
+  eval "$cmd"
+  TEST_EQ "$cmd" $? 0
+
+  TEST_NE "HOME" "$HOME" ""
+}
+
+cleanup()
+{
+  if [ -d "$test_dir" ]
+  then
+    echo "Removing test directory '$test_dir'"
+    cmd="rmdir \"$test_dir\""
+    eval "$cmd"
+    TEST_EQ "$cmd" $? 0
+  fi
+}
+
+ensure_job_known()
+{
+  job="$1"
+  job_name="$2"
+
+  [ -z "$job" ] && die "no job"
+  [ -z "$job_name" ] && die "no job name"
+
+  TEST_FEATURE "ensure 'initctl' recognises job"
+  initctl list|grep -q "^$job " || \
+    TEST_FAILED "job $job_name not known to initctl"
+
+  TEST_FEATURE "ensure 'status' recognises job"
+  cmd="status ${job}"
+  eval "$cmd" >/dev/null 2>&1
+  rc=$?
+  TEST_EQ "$cmd" $rc 0
+}
+
+# Note that if the specified job is *not* as task, it is expected to run
+# indefinately. This allows us to perform PID checks, etc.
+run_user_job_tests()
+{
+  job_name="$1"
+  job_file="$2"
+  task="$3"
+  env="$4"
+
+  # XXX: env can be empty
+  [ -z "$job_name" ] && die "no job name"
+  [ -z "$job_file" ] && die "no job file"
+  [ -z "$task" ] && die "no task value"
+
+  job="${test_dir_suffix}/${job_name}"
+
+  [ -f "$job_file" ] || TEST_FAILED "job file '$job_file' does not exist"
+
+  ensure_job_known "$job" "$job_name"
+
+  TEST_FEATURE "ensure job can be started"
+  cmd="start ${job} ${env}"
+  output=$(eval "$cmd")
+  rc=$?
+  TEST_EQ "$cmd" $rc 0
+
+  if [ "$task" = no ]
+  then
+    TEST_FEATURE "ensure 'start' shows job pid"
+    pid=$(echo "$output"|awk '{print $4}')
+    TEST_NE "pid" "$pid" ""
+
+    TEST_FEATURE "ensure 'initctl' shows job is running with pid"
+    initctl list|grep -q "^$job start/running, process $pid" || \
+      TEST_FAILED "job $job_name did not start"
+
+    TEST_FEATURE "ensure 'status' shows job is running with pid"
+    cmd="status ${job}"
+    output=$(eval "$cmd")
+    echo "$output"|while read job_tmp state ignored status_pid
+    do
+      state=$(echo $state|tr -d ',')
+      TEST_EQ "job name"  "$job_tmp" "$job"
+      TEST_EQ "job state" "$state" "start/running"
+      TEST_EQ "job pid"   "$status_pid" "$pid"
+    done
+
+    TEST_FEATURE "ensure job pid is running with correct uids"
+    pid_uids=$(ps --no-headers -p $pid -o euid,ruid)
+    for pid_uid in $pid_uids
+    do
+      TEST_EQ "pid uid" "$pid_uid" "$uid"
+    done
+
+    TEST_FEATURE "ensure job pid is running with correct gids"
+    pid_gids=$(ps --no-headers -p $pid -o egid,rgid)
+    for pid_gid in $pid_gids
+    do
+      TEST_EQ "pid gid" "$pid_gid" "$gid"
+    done
+
+    TEST_FEATURE "ensure process is running in correct directory"
+    cwd=$(readlink /proc/$pid/cwd)
+    TEST_EQ "cwd" "$cwd" "$HOME"
+
+    TEST_FEATURE "ensure job can be stopped"
+    cmd="stop ${job}"
+    output=$(eval "$cmd")
+    rc=$?
+    TEST_EQ "$cmd" $rc 0
+
+    TEST_FEATURE "ensure job pid no longer exists"
+    pid_ids=$(ps --no-headers -p $pid -o euid,ruid,egid,rgid)
+    TEST_EQ "pid uids+gids" "$pid_ids" ""
+  fi
+
+  remove_job_file "$job_file"
+  ensure_job_gone "$job" "$job_name" "$env"
+}
+
+remove_job_file()
+{
+  job_file="$1"
+
+  [ -z "$job_file" ] && die "no job file"
+  [ ! -f "$job_file" ] && TEST_FAILED "job file '$job_file' does not exist"
+
+  cmd="rm $job_file"
+  eval "$cmd"
+  TEST_EQ "$cmd" $? 0
+}
+
+ensure_job_gone()
+{
+  job="$1"
+  job_name="$2"
+  env="$3"
+
+  # XXX: no check on env since it can be empty
+  [ -z "$job" ] && die "no job"
+  [ -z "$job_name" ] && die "no job name"
+
+  TEST_FEATURE "ensure 'initctl' no longer recognises job"
+  initctl list|grep -q "^$job " && \
+    TEST_FAILED "deleted job $job_name still known to initctl"
+
+  TEST_FEATURE "ensure 'status' no longer recognises job"
+  cmd="status ${job}"
+  eval "$cmd" >/dev/null 2>&1
+  rc=$?
+  TEST_NE "$cmd" $rc 0
+}
+
+test_user_job()
+{
+  test_group="$1"
+  job_name="$2"
+  script="$3"
+  task="$4"
+  env="$5"
+
+  # XXX: no test on script or env since they might be empty
+  [ -z "$test_group" ] && die "no test group"
+  [ -z "$job_name" ] && die "no job name"
+  [ -z "$task" ] && die "no task"
+
+  TEST_GROUP "$test_group"
+
+  job_file="${test_dir}/${job_name}.conf"
+
+  echo "$script" > $job_file
+
+  run_user_job_tests "$job_name" "$job_file" "$task" "$env"
+}
+
+test_user_job_binary()
+{
+  group="user job running a binary"
+  job_name="binary_test"
+  script="exec sleep 999"
+  test_user_job "$group" "$job_name" "$script" no ""
+}
+
+test_user_job_binary_task()
+{
+  group="user job running a binary task"
+  job_name="binary_task_test"
+  OUTFILE=$(mktemp)
+
+  script="\
+task
+exec /bin/true > $OUTFILE"
+
+  test_user_job "$group" "$job_name" "$script" yes "OUTFILE=$OUTFILE"
+  rm -f $OUTFILE
+}
+
+test_user_job_single_line_script()
+{
+  group="user job running a single-line script"
+  job_name="single_line_script_test"
+  script="\
+script
+  sleep 999
+end script"
+  test_user_job "$group" "$job_name" "$script" no ""
+}
+
+test_user_job_single_line_script_task()
+{
+  group="user job running a single-line script task"
+  job_name="single_line_script_task_test"
+  OUTFILE=$(mktemp)
+
+  script="\
+task
+script
+  exec /bin/true > $OUTFILE
+end script"
+  test_user_job "$group" "$job_name" "$script" yes "OUTFILE=$OUTFILE"
+  rm -f $OUTFILE
+}
+
+test_user_job_multi_line_script()
+{
+  group="user job running a multi-line script"
+  job_name="multi_line_script_test"
+  script="\
+script
+
+  /bin/true
+  /bin/true;/bin/true
+  sleep 999
+
+end script"
+  test_user_job "$group" "$job_name" "$script" no ""
+}
+
+test_user_job_multi_line_script_task()
+{
+  group="user job running a multi-line script task"
+  job_name="multi_line_script_task_test"
+  OUTFILE=$(mktemp)
+
+  script="\
+task
+script
+
+  /bin/true
+  /bin/true
+  /bin/true
+
+end script"
+  test_user_job "$group" "$job_name" "$script" yes "OUTFILE=$OUTFILE"
+  rm -f $OUTFILE
+}
+
+test_user_emit_events()
+{
+  job_name="start_on_foo"
+
+  TEST_GROUP "user emitting an event"
+  initctl emit foo || TEST_FAILED "failed to emit event as user"
+
+  TEST_GROUP "user emitting an event to start a job"
+  script="\
+    start on foo BAR=2
+    stop on baz cow=moo or hello
+    exec sleep 999"
+
+  job_file="${test_dir}/${job_name}.conf"
+  job="${test_dir_suffix}/${job_name}"
+
+  echo "$script" > $job_file
+
+  ensure_job_known "$job" "$job_name"
+
+  initctl list|grep -q "^$job stop/waiting" || \
+      TEST_FAILED "job $job_name not stopped"
+
+  TEST_FEATURE "ensure job can be started with event"
+  initctl emit foo BAR=2 || \
+    TEST_FAILED "failed to emit event for user job"
+
+  initctl status "$job"|grep -q "^$job start/running" || \
+      TEST_FAILED "job $job_name failed to start"
+
+  TEST_FEATURE "ensure job can be stopped with event"
+  initctl emit baz cow=moo || \
+    TEST_FAILED "failed to emit event for user job"
+
+  initctl list|grep -q "^$job stop/waiting" || \
+      TEST_FAILED "job $job_name not stopped"
+
+  rm -f "$job_file"
+}
+
+test_user_job_setuid_setgid()
+{
+    group="user job with setuid and setgid me"
+    job_name="setuid_setgid_me_test"
+    script="\
+setuid $(id -un)
+setgid $(id -gn)
+exec sleep 999"
+    test_user_job "$group" "$job_name" "$script" no ""
+
+    TEST_GROUP "user job with setuid and setgid root"
+    script="\
+setuid root
+setgid root
+exec sleep 999"
+
+    job_name="setuid_setgid_root_test"
+    job_file="${test_dir}/${job_name}.conf"
+    job="${test_dir_suffix}/${job_name}"
+
+    echo "$script" > $job_file
+
+    ensure_job_known "$job" "$job_name"
+
+    TEST_FEATURE "ensure job fails to start as root"
+    cmd="start ${job}"
+    output=$(eval "$cmd" 2>&1)
+    rc=$?
+    TEST_EQ "$cmd" $rc 1
+
+    TEST_FEATURE "ensure 'start' indicates job failure"
+    error=$(echo "$output"|grep failed)
+    TEST_NE "error" "$error" ""
+
+    TEST_FEATURE "ensure 'initctl' does not list job"
+    initctl list|grep -q "^$job stop/waiting" || \
+        TEST_FAILED "job $job_name not listed as stopped"
+
+    delete_job "$job_name"
+}
+
+get_job_file()
+{
+  job_name="$1"
+
+  [ -z "$job_name" ] && die "no job name"
+  echo "${test_dir}/${job_name}.conf"
+}
+
+ensure_no_output()
+{
+  job_name="$1"
+  script="$2"
+  instance="$3"
+
+  job="${test_dir_suffix}/${job_name}"
+
+  create_job "$job_name" "$script"
+  start_job "$job" "$job_name" "$instance"
+
+  check_job_output "$job_name"
+  delete_job "$job_name"
+}
+
+create_job()
+{
+  job_name="$1"
+  script="$2"
+
+  # XXX: script could be empty
+  [ -z "$job_name" ] && die "no job name"
+
+  debug "create_job: job_name='$job_name'"
+  debug "create_job: script='$script'"
+
+  # Not currently possible to have a user job with the
+  # same name as a system job.
+  #
+  # XXX: Note that this test assumes that user has *not* specified
+  # XXX: an alternate configuration directory using the
+  # XXX: '--confdir' option.
+  [ -e "${sys_job_dir}/${job_name}.conf" ] && \
+    die "job '$job_name' already exists as a system job"
+
+  job_file="${test_dir}/${job_name}.conf"
+  job="${test_dir_suffix}/${job_name}"
+
+  echo "$script" > "$job_file"
+  sync
+}
+
+delete_job()
+{
+  job_name="$1"
+
+  [ -z "$job_name" ] && die "no job name"
+
+  job_file="$(get_job_file $job_name)"
+
+  rm "$job_file" || TEST_FAILED "unable to remove job file '$job_file'"
+}
+
+check_job_output()
+{
+  job_name="$1"
+
+  [ ! -z "$(ls $user_log_dir 2>/dev/null)" ] && \
+    TEST_FAILED "job $job_name created logfile unexpectedly in '$user_log_dir'"
+
+  # XXX: note that it might appear that checking in $sys_log_dir
+  # could result in false positives, but this isn't so since
+  # (currently) it is not possible for a user job to have the
+  # same name as a system job. start_job() will detect this
+  # scenario.
+  for dir in "$user_log_dir" "$sys_log_dir"
+  do
+    log_file="${dir}/${job_name}.log"
+    [ -f "$log_file" ] && \
+      TEST_FAILED "job $job_name created logfile unexpectedly as '$log_file'"
+  done
+}
+
+start_job()
+{
+  job="$1"
+  job_file="$2"
+  instance="$3"
+  allow_failure="$4"
+
+  # XXX: instance may be blank
+  [ -z "$job" ] && die "no job"
+  [ -z "$job_file" ] && die "no job file"
+
+  debug "start_job: job='$job'"
+  debug "start_job: job_file='$job_file'"
+  debug "start_job: instance='$instance'"
+  debug "start_job: allow_failure='$allow_failure'"
+
+  eval output=$(mktemp)
+
+  # XXX: Don't quote instance as we don't want to pass a null instance to
+  # start(8).
+  cmd="start \"$job\" $instance >${output} 2>&1"
+  debug "start_job: running '$cmd'"
+  eval "$cmd"
+  rc=$?
+
+  if [ $rc -ne 0 -a -z "$allow_failure" ]
+  then
+    TEST_FAILED "job $job_file not started: $(cat $output)"
+  fi
+
+  rm -f "$output"
+}
+
+get_job_logfile_name()
+{
+  job_name="$1"
+  instance_value="$2"
+
+  # XXX: instance may be null
+  [ -z "$job_name" ] && die "no job name"
+
+  encoded_test_dir_suffix=$(upstart_encode "${test_dir_suffix}/")
+  file_name="${encoded_test_dir_suffix}$(make_log_name $job_name)"
+
+  if [ ! -z "$instance_value" ]
+  then
+    log_file="${user_log_dir}/${file_name}-${instance_value}.log"
+  else
+    log_file="${user_log_dir}/${file_name}.log"
+  fi
+
+  echo "$log_file"
+}
+
+run_job()
+{
+  job="$1"
+  job_name="$2"
+  script="$3"
+  instance="$4"
+
+  # XXX: script, instance might be blank
+  [ -z "$job" ] && die "no job"
+  [ -z "$job_name" ] && die "no job name"
+
+  debug "run_job: job='$job'"
+  debug "run_job: job_name='$job_name'"
+  debug "run_job: script='$script'"
+  debug "run_job: instance='$instance'"
+
+  create_job "$job_name" "$script"
+  start_job "$job" "$job_name" "$instance"
+}
+
+ensure_file_meta()
+{
+  file="$1"
+  expected_owner="$2"
+  expected_group="$3"
+  expected_perms="$4"
+
+  [ -z "$file" ] && die "no file"
+  [ -z "$expected_owner" ] && die "no expected owner"
+  [ -z "$expected_group" ] && die "no expected group"
+  [ -z "$expected_perms" ] && die "no expected perms"
+
+  [ ! -f "$file" ] && die "file $file does not exist"
+
+  expected_perms="640"
+  umask_value=$(umask)
+  umask_expected=0022
+
+  if [ "$umask_value" != "$umask_expected" ]
+  then
+    msg="umask value is $umask_value -"
+    msg="${msg} changing it to $umask_expected."
+    echo "WARNING: $msg"
+    umask "$umask_expected" || TEST_FAILED "unable to change umask"
+  fi
+
+  owner=$(ls -l "$file"|awk '{print $3}')
+  group=$(ls -l "$file"|awk '{print $4}')
+  perms=$(stat --printf "%a\n" "$file")
+
+  [ "$owner" = "$expected_owner" ] || TEST_FAILED \
+    "file $file has wrong owner (expected $expected_owner, got $owner)"
+
+  [ "$group" = "$expected_group" ] || TEST_FAILED \
+    "file $file has wrong group (expected $expected_group, got $group)"
+
+  [ "$perms" = "$expected_perms" ] || TEST_FAILED \
+    "file $file has wrong group (expected $expected_perms, got $perms)"
+}
+
+
+ensure_output()
+{
+  job_name="$1"
+  script="$2"
+  expected_output="$3"
+  instance="$4"
+  instance_value="$5"
+  options="$6"
+
+  # XXX: remaining args could be null
+  [ -z "$job_name" ] && die "no job name"
+
+  debug "ensure_output: job_name='$job_name'"
+  debug "ensure_output: script='$script'"
+  debug "ensure_output: expected_ouput='$expected_ouput'"
+  debug "ensure_output: instance='$instance'"
+  debug "ensure_output: instance_value='$instance_value'"
+  debug "ensure_output: options='$options'"
+
+  regex=n
+  retain=n
+  unique=""
+  use_od=n
+
+  for opt in $options
+  do
+    case "$opt" in
+      regex)
+        regex=y
+        ;;
+      retain)
+        retain=y
+        ;;
+      unique)
+        unique='|sort -u'
+        ;;
+      use_od)
+        use_od=y
+        ;;
+    esac
+  done
+
+  debug "ensure_output: regex='$regex'"
+  debug "ensure_output: retain='$retain'"
+  debug "ensure_output: unique='$unique'"
+  debug "ensure_output: use_od='$use_od'"
+
+  expected_owner=$(id -un)
+  expected_group=$(id -gn)
+  expected_perms="640"
+
+  job="${test_dir_suffix}/${job_name}"
+
+  run_job "$job" "$job_name" "$script" "$instance"
+
+  debug "ensure_output: user_log_dir='$user_log_dir'"
+  debug "ensure_output: test_dir='$test_dir'"
+  debug "ensure_output: test_dir_suffix='$test_dir_suffix'"
+
+  log_file=$(get_job_logfile_name "$job_name" "$instance_value")
+
+  debug "ensure_output: log_file='$log_file'"
+
+  # Give Upstart a chance to parse the file
+  count=1
+  while ! status "$job" >/dev/null 2>&1
+  do
+    sleep 1
+    count=$((count+1))
+    [ "$count" -eq 5 ] && break
+  done
+
+  # give job a chance to start
+  count=1
+  while [ ! -f "$log_file" ]
+  do
+    sleep 1
+    count=$((count+1))
+    [ "$count" -eq 5 ] && break
+  done
+
+  [ ! -f "$log_file" ] && \
+      TEST_FAILED "job '$job_name' failed to create logfile"
+
+  ensure_file_meta \
+    "$log_file" \
+    "$expected_owner" \
+    "$expected_group" \
+    "$expected_perms"
+
+  # XXX: note we have to remove carriage returns added by the line
+  # discipline
+  if [ "$regex" = y ]
+  then
+    log=$(eval "cat $log_file|tr -d '\r' $unique")
+    msg="job '$job_name' failed to log correct data\n"
+    msg="${msg}\texpected regex: '$expected_output'\n"
+    msg="${msg}\tgot           : '$log'"
+    cat "$log_file" | egrep "$expected_output" || TEST_FAILED "$msg"
+  elif [ "$use_od" = y ]
+  then
+    log=$(eval "cat $log_file|tr -d '\r' $unique|od -x")
+    msg="job '$job_name' failed to log correct data\n"
+    msg="${msg}\texpected hex: '$expected_output'\n"
+    msg="${msg}\tgot         : '$log'"
+    [ "$expected_output" != "$log" ] && TEST_FAILED "$msg"
+  else
+    log=$(eval "cat $log_file|tr -d '\r' $unique")
+    msg="job '$job_name' failed to log correct data\n"
+    msg="${msg}\texpected text: '$expected_output'\n"
+    msg="${msg}\tgot          : '$log'"
+    [ "$expected_output" != "$log" ] && TEST_FAILED "$msg"
+  fi
+
+  if [ "$retain" = n ]
+  then
+    delete_job "$job_name"
+    rm "$log_file" || TEST_FAILED "unable to remove log file '$log_file'"
+  fi
+}
+
+test_ensure_no_unexpected_output()
+{
+  #---------------------------------------------------------------------
+  feature="ensure command job does not create log file with no console"
+  TEST_FEATURE "$feature"
+
+  job_name=$(make_job_name "$feature")
+
+  script="\
+    console none
+    exec echo hello world"
+
+  ensure_no_output "$job_name" "$script" ""
+
+  #---------------------------------------------------------------------
+  feature="ensure 1-line script job does not create log file with no console"
+  TEST_FEATURE "$feature"
+
+  job_name=$(make_job_name "$feature")
+
+  script="\
+    console none
+    script
+      echo hello world
+    end script
+  "
+
+  ensure_no_output "$job_name" "$script" ""
+
+  #---------------------------------------------------------------------
+  feature="ensure multi-line script job does not create log file with no console"
+  TEST_FEATURE "$feature"
+
+  job_name=$(make_job_name "$feature")
+
+  script="\
+    console none
+    script
+      /bin/true
+      echo hello world
+    end script
+  "
+
+  ensure_no_output "$job_name" "$script" ""
+
+  #---------------------------------------------------------------------
+  feature="ensure no output if log directory does not exist"
+  TEST_FEATURE "$feature"
+
+  rmdir "${user_log_dir}" || \
+    TEST_FAILED "unable to delete log directory '$user_log_dir'"
+
+  job_name=$(make_job_name "$feature")
+  string="hello world"
+  script="\
+    console log
+    script
+      /bin/true
+      /bin/echo hello world
+    end script
+  "
+
+  ensure_no_output "$job_name" "$script" ""
+
+  mkdir "${user_log_dir}" || \
+    TEST_FAILED "unable to recreate log directory '$user_log_dir'"
+
+  #---------------------------------------------------------------------
+  feature="ensure command job does not create log file with invalid command"
+  TEST_FEATURE "$feature"
+
+  job_name=$(make_job_name "$feature")
+
+  script="\
+    console log
+    exec /this/command/does/not/exist"
+
+  job="${test_dir_suffix}/${job_name}"
+  create_job "$job_name" "$script"
+  start_job "$job" "$job_name" "" 1
+  check_job_output "$job_name"
+  delete_job "$job_name"
+}
+
+test_output_logged()
+{
+  # XXX: upstart won't create this
+  mkdir -p "$user_log_dir"
+
+  test_ensure_no_unexpected_output
+}
+
+test_user_jobs()
+{
+  test_user_job_binary
+  test_user_job_single_line_script
+  test_user_job_multi_line_script
+
+  test_user_job_binary_task
+  test_user_job_single_line_script_task
+  test_user_job_multi_line_script_task
+
+  test_user_job_setuid_setgid
+
+  test_user_emit_events
+
+  test_output_logged
+}
+
+tests()
+{
+  echo
+  echo -n "Running Upstart user session tests as user '`whoami`'"
+  echo " (uid $uid, gid $gid) in directory '$test_dir'"
+  echo
+
+  test_user_jobs
+
+  echo
+  echo "All tests completed successfully"
+  echo
+}
+
+usage()
+{
+cat <<EOT
+USAGE: $script_name [options]
+
+OPTIONS:
+
+ -a        : Actually run this script.
+ -h        : Show this help.
+ -u <user> : Specify name of test user to create.
+
+DESCRIPTION:
+
+Run simple set of Upstart user session tests.
+
+PREREQUISITE:
+
+For this test to run, non-root users must be allowed to invoke all D-Bus
+methods on Upstart via configuration file:
+
+  /etc/dbus-1/system.d/Upstart.conf 
+
+See dbus-daemon(1) for further details.
+
+WARNING: Note that this script is unavoidably invasive, so read what
+WARNING: follows before running!
+
+If run as a non-root user, this script will create a uniquely-named
+subdirectory below "\$HOME/.init/" to run its tests in. On successful
+completion of these tests, the unique subdirectory and its contents will
+be removed.
+
+If however, this script is invoked as the root user, the script will
+refuse to run until given the name of a test user to create via the "-u"
+option. If the user specified to this option already exists, this script
+will exit with an error. If the user does not already exist, it will be
+created, the script then run *as that user* and assuming successful
+completion of the tests, the test user and their home directory will
+then be deleted.
+
+EOT
+}
+
+#---------------------------------------------------------------------
+# main
+#---------------------------------------------------------------------
+
+while getopts "dhu:" opt
+do
+  case "$opt" in
+    d)
+      debug_enabled=1
+    ;;
+
+    h)
+      usage
+      exit 0
+    ;;
+
+    u)
+      user_to_create="$OPTARG"
+    ;;
+  esac
+done
+
+setup
+tests
+cleanup
+exit 0
